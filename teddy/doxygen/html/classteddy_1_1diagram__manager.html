<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TeDDy: teddy::diagram_manager&lt; Data, Degree, Domain &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TeDDy<span id="projectnumber">&#160;4.1.0</span>
   </div>
   <div id="projectbrief">Decision diagram library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>teddy</b></li><li class="navelem"><a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classteddy_1_1diagram__manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">teddy::diagram_manager&lt; Data, Degree, Domain &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for all diagram managers that generically implements all of the algorithms.  
 <a href="classteddy_1_1diagram__manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="diagram__manager_8hpp_source.html">diagram_manager.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for teddy::diagram_manager&lt; Data, Degree, Domain &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classteddy_1_1diagram__manager.png" usemap="#teddy::diagram_5Fmanager_3C_20Data_2C_20Degree_2C_20Domain_20_3E_map" alt=""/>
  <map id="teddy::diagram_5Fmanager_3C_20Data_2C_20Degree_2C_20Domain_20_3E_map" name="teddy::diagram_5Fmanager_3C_20Data_2C_20Degree_2C_20Domain_20_3E_map">
<area href="classteddy_1_1reliability__manager.html" alt="teddy::reliability_manager&lt; degrees::fixed&lt; 2 &gt;, domains::fixed&lt; 2 &gt; &gt;" shape="rect" coords="0,56,417,80"/>
<area href="classteddy_1_1reliability__manager.html" alt="teddy::reliability_manager&lt; degrees::fixed&lt; M &gt;, domains::mixed &gt;" shape="rect" coords="427,56,844,80"/>
<area href="classteddy_1_1reliability__manager.html" alt="teddy::reliability_manager&lt; degrees::mixed, domains::mixed &gt;" shape="rect" coords="854,56,1271,80"/>
<area href="classteddy_1_1reliability__manager.html" alt="teddy::reliability_manager&lt; degrees::fixed&lt; M &gt;, domains::fixed&lt; M &gt; &gt;" shape="rect" coords="1281,56,1698,80"/>
<area href="structteddy_1_1bss__manager.html" title="Manager for BDDs and analysis of Binary State System." alt="teddy::bss_manager" shape="rect" coords="0,112,417,136"/>
<area href="structteddy_1_1ifmss__manager.html" title="Manager for iMDDs and analysis of non-homogenous Multi-state Systems." alt="teddy::ifmss_manager&lt; M &gt;" shape="rect" coords="427,112,844,136"/>
<area href="structteddy_1_1imss__manager.html" title="Manager for iMDDs and analysis of non-homogenous Multi-state Systems." alt="teddy::imss_manager" shape="rect" coords="854,112,1271,136"/>
<area href="structteddy_1_1mss__manager.html" title="Manager for MDDs and analysis of homogeneous Multi-State Systems." alt="teddy::mss_manager&lt; M &gt;" shape="rect" coords="1281,112,1698,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afd258af2e42689cd3887b7c7acd7c64a"><td class="memItemLeft" align="right" valign="top"><a id="afd258af2e42689cd3887b7c7acd7c64a" name="afd258af2e42689cd3887b7c7acd7c64a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>diagram_t</b> = <a class="el" href="classteddy_1_1diagram.html">diagram</a>&lt; Data, Degree &gt;</td></tr>
<tr class="memdesc:afd258af2e42689cd3887b7c7acd7c64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the diagram type used in the functions of this manager. <br /></td></tr>
<tr class="separator:afd258af2e42689cd3887b7c7acd7c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae9b81bc96567b5e59b0ae4326e83d14"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aae9b81bc96567b5e59b0ae4326e83d14">constant</a> (int32 val) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:aae9b81bc96567b5e59b0ae4326e83d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram representing constant function.  <br /></td></tr>
<tr class="separator:aae9b81bc96567b5e59b0ae4326e83d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a825b2e44e0f2480b6cb272f8877661"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a7a825b2e44e0f2480b6cb272f8877661">variable</a> (int32 index) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a7a825b2e44e0f2480b6cb272f8877661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram representing function of single variable.  <br /></td></tr>
<tr class="separator:a7a825b2e44e0f2480b6cb272f8877661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad453049e900b8c4bc304737f40c7c098"><td class="memTemplParams" colspan="2">template&lt;class Foo  = void&gt; <br />
requires (is_bdd&lt;Degree&gt;)</td></tr>
<tr class="memitem:ad453049e900b8c4bc304737f40c7c098"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ad453049e900b8c4bc304737f40c7c098">variable_not</a> (int32 index) -&gt; utils::second_t&lt; Foo, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:ad453049e900b8c4bc304737f40c7c098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates BDD representing function of complemented variable.  <br /></td></tr>
<tr class="separator:ad453049e900b8c4bc304737f40c7c098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c971ef459dd59243445daafb142d01"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ad7c971ef459dd59243445daafb142d01">operator()</a> (int32 index) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:ad7c971ef459dd59243445daafb142d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram representing function of single variable.  <br /></td></tr>
<tr class="separator:ad7c971ef459dd59243445daafb142d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a278e6eeebcc1d87a0c1ee539e512e"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; int32 &gt; T&gt; </td></tr>
<tr class="memitem:a96a278e6eeebcc1d87a0c1ee539e512e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a96a278e6eeebcc1d87a0c1ee539e512e">variables</a> (std::initializer_list&lt; T &gt; indices) -&gt; std::vector&lt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:a96a278e6eeebcc1d87a0c1ee539e512e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates vector of diagrams representing single variables.  <br /></td></tr>
<tr class="separator:a96a278e6eeebcc1d87a0c1ee539e512e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f56f39c209510b6602ab6863e30899"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </td></tr>
<tr class="memitem:a80f56f39c209510b6602ab6863e30899"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a80f56f39c209510b6602ab6863e30899">variables</a> (I first, S last) -&gt; std::vector&lt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:a80f56f39c209510b6602ab6863e30899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates vector of diagrams representing functions of single variables.  <br /></td></tr>
<tr class="separator:a80f56f39c209510b6602ab6863e30899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fa2f23c486004004e7655ee219121f"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range Is&gt; </td></tr>
<tr class="memitem:a88fa2f23c486004004e7655ee219121f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a88fa2f23c486004004e7655ee219121f">variables</a> (Is const &amp;indices) -&gt; std::vector&lt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:a88fa2f23c486004004e7655ee219121f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates vector of diagrams representing single variables.  <br /></td></tr>
<tr class="separator:a88fa2f23c486004004e7655ee219121f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926f78f0cea41fd1d3b0ab71d3ff732c"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </td></tr>
<tr class="memitem:a926f78f0cea41fd1d3b0ab71d3ff732c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a926f78f0cea41fd1d3b0ab71d3ff732c">from_vector</a> (I first, S last) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a926f78f0cea41fd1d3b0ab71d3ff732c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram from a truth vector of a function.  <br /></td></tr>
<tr class="separator:a926f78f0cea41fd1d3b0ab71d3ff732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669d1358d90dc81f5b7205589fd89bd"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range R&gt; </td></tr>
<tr class="memitem:a9669d1358d90dc81f5b7205589fd89bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a9669d1358d90dc81f5b7205589fd89bd">from_vector</a> (R &amp;&amp;vector) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a9669d1358d90dc81f5b7205589fd89bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram from a truth vector of a function.  <br /></td></tr>
<tr class="separator:a9669d1358d90dc81f5b7205589fd89bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b38d2cfc763ec18460e285ae5fba79"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a42b38d2cfc763ec18460e285ae5fba79">to_vector</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) const -&gt; std::vector&lt; int32 &gt;</td></tr>
<tr class="memdesc:a42b38d2cfc763ec18460e285ae5fba79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates truth vector from the diagram.  <br /></td></tr>
<tr class="separator:a42b38d2cfc763ec18460e285ae5fba79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ac10a68e553087882a6ae18383bd8d"><td class="memTemplParams" colspan="2">template&lt;std::output_iterator&lt; teddy::int32 &gt; O&gt; </td></tr>
<tr class="memitem:aa6ac10a68e553087882a6ae18383bd8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aa6ac10a68e553087882a6ae18383bd8d">to_vector_g</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>, O out) const -&gt; void</td></tr>
<tr class="memdesc:aa6ac10a68e553087882a6ae18383bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates truth vector from the diagram.  <br /></td></tr>
<tr class="separator:aa6ac10a68e553087882a6ae18383bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb509e477341e7f39c7dbc60ca2dfbb8"><td class="memTemplParams" colspan="2">template&lt;class Foo  = void&gt; <br />
requires (is_bdd&lt;Degree&gt;)</td></tr>
<tr class="memitem:abb509e477341e7f39c7dbc60ca2dfbb8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#abb509e477341e7f39c7dbc60ca2dfbb8">from_pla</a> (<a class="el" href="classteddy_1_1pla__file.html">pla_file</a> const &amp;file, fold_type foldType=fold_type::Tree) -&gt; utils::second_t&lt; Foo, std::vector&lt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt; &gt;</td></tr>
<tr class="memdesc:abb509e477341e7f39c7dbc60ca2dfbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates BDDs defined by PLA file.  <br /></td></tr>
<tr class="separator:abb509e477341e7f39c7dbc60ca2dfbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc4407d2bb8e97961bdbddf53d21e3e"><td class="memTemplParams" colspan="2">template&lt;expression_node Node&gt; </td></tr>
<tr class="memitem:a5cc4407d2bb8e97961bdbddf53d21e3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a5cc4407d2bb8e97961bdbddf53d21e3e">from_expression_tree</a> (Node const &amp;root) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a5cc4407d2bb8e97961bdbddf53d21e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram from an expression tree (AST).  <br /></td></tr>
<tr class="separator:a5cc4407d2bb8e97961bdbddf53d21e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8a9698ab261c0ed323e4743bce5678"><td class="memTemplParams" colspan="2">template&lt;teddy_bin_op Op&gt; </td></tr>
<tr class="memitem:a4a8a9698ab261c0ed323e4743bce5678"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a4a8a9698ab261c0ed323e4743bce5678">apply</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;lhs, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;rhs) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a4a8a9698ab261c0ed323e4743bce5678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two diagrams using given binary operation.  <br /></td></tr>
<tr class="separator:a4a8a9698ab261c0ed323e4743bce5678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cee4d7c96c9735433cf3515577b0a78"><td class="memTemplParams" colspan="2"><a id="a3cee4d7c96c9735433cf3515577b0a78" name="a3cee4d7c96c9735433cf3515577b0a78"></a>
template&lt;teddy_bin_op Op, class... Diagram&gt; </td></tr>
<tr class="memitem:a3cee4d7c96c9735433cf3515577b0a78"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_n</b> (Diagram const &amp;... diagrams) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a3cee4d7c96c9735433cf3515577b0a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO. <br /></td></tr>
<tr class="separator:a3cee4d7c96c9735433cf3515577b0a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bcef18a79702ade105fc8de1ac69cb"><td class="memTemplParams" colspan="2">template&lt;teddy_bin_op Op, std::ranges::input_range R&gt; </td></tr>
<tr class="memitem:af9bcef18a79702ade105fc8de1ac69cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#af9bcef18a79702ade105fc8de1ac69cb">left_fold</a> (R const &amp;diagrams) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:af9bcef18a79702ade105fc8de1ac69cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges diagams in the range using the <code>apply</code> function and binary operation.  <br /></td></tr>
<tr class="separator:af9bcef18a79702ade105fc8de1ac69cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9954a79a74936ba6494ec15c1cc517e3"><td class="memTemplParams" colspan="2">template&lt;teddy_bin_op Op, std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </td></tr>
<tr class="memitem:a9954a79a74936ba6494ec15c1cc517e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a9954a79a74936ba6494ec15c1cc517e3">left_fold</a> (I first, S last) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a9954a79a74936ba6494ec15c1cc517e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges diagams in the range using the <code>apply</code> function and binary operation.  <br /></td></tr>
<tr class="separator:a9954a79a74936ba6494ec15c1cc517e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7cc644478b9cc47858ba69fb38dc81"><td class="memTemplParams" colspan="2">template&lt;teddy_bin_op Op, std::ranges::random_access_range R&gt; </td></tr>
<tr class="memitem:a7a7cc644478b9cc47858ba69fb38dc81"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a7a7cc644478b9cc47858ba69fb38dc81">tree_fold</a> (R &amp;diagrams) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a7a7cc644478b9cc47858ba69fb38dc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges diagams in the range using the <code>apply</code> function and binary operation.  <br /></td></tr>
<tr class="separator:a7a7cc644478b9cc47858ba69fb38dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84d0aa56905007fa98c48cd2b9f9ae0"><td class="memTemplParams" colspan="2">template&lt;teddy_bin_op Op, std::random_access_iterator I, std::sentinel_for&lt; I &gt; S&gt; </td></tr>
<tr class="memitem:af84d0aa56905007fa98c48cd2b9f9ae0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#af84d0aa56905007fa98c48cd2b9f9ae0">tree_fold</a> (I first, S last) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:af84d0aa56905007fa98c48cd2b9f9ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges diagams in the range using the <code>apply</code> function and binary operation.  <br /></td></tr>
<tr class="separator:af84d0aa56905007fa98c48cd2b9f9ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b10389b7f067f73252fecbbce0e4ad"><td class="memTemplParams" colspan="2">template&lt;in_var_values Vars&gt; </td></tr>
<tr class="memitem:ab3b10389b7f067f73252fecbbce0e4ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ab3b10389b7f067f73252fecbbce0e4ad">evaluate</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>, Vars const &amp;values) const -&gt; int32</td></tr>
<tr class="memdesc:ab3b10389b7f067f73252fecbbce0e4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates value of the function represented by the diagram.  <br /></td></tr>
<tr class="separator:ab3b10389b7f067f73252fecbbce0e4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4b2afdbaa516984c4fe9144432dfc6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a5f4b2afdbaa516984c4fe9144432dfc6">satisfy_count</a> (int32 value, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) -&gt; int64</td></tr>
<tr class="memdesc:a5f4b2afdbaa516984c4fe9144432dfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of variable assignments for which the functions evaluates to certain value.  <br /></td></tr>
<tr class="separator:a5f4b2afdbaa516984c4fe9144432dfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8de2bb90b83e16ac5e33400d3d9aef"><td class="memTemplParams" colspan="2">template&lt;out_var_values Vars&gt; </td></tr>
<tr class="memitem:aaa8de2bb90b83e16ac5e33400d3d9aef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aaa8de2bb90b83e16ac5e33400d3d9aef">satisfy_one</a> (int32 value, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) -&gt; std::optional&lt; Vars &gt;</td></tr>
<tr class="memdesc:aaa8de2bb90b83e16ac5e33400d3d9aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds variable assignment for which diagram evaluates to <code>value</code>.  <br /></td></tr>
<tr class="separator:aaa8de2bb90b83e16ac5e33400d3d9aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc05f6a6eb33c0638fbad192a0c7eda3"><td class="memTemplParams" colspan="2">template&lt;out_var_values Vars&gt; </td></tr>
<tr class="memitem:adc05f6a6eb33c0638fbad192a0c7eda3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#adc05f6a6eb33c0638fbad192a0c7eda3">satisfy_all</a> (int32 value, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) const -&gt; std::vector&lt; Vars &gt;</td></tr>
<tr class="memdesc:adc05f6a6eb33c0638fbad192a0c7eda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all elements of the satisfying set.  <br /></td></tr>
<tr class="separator:adc05f6a6eb33c0638fbad192a0c7eda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacbb6b7289fca260cf245602b992538"><td class="memTemplParams" colspan="2">template&lt;out_var_values Vars, std::output_iterator&lt; Vars &gt; O&gt; </td></tr>
<tr class="memitem:aeacbb6b7289fca260cf245602b992538"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aeacbb6b7289fca260cf245602b992538">satisfy_all_g</a> (int32 value, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>, O out) const -&gt; void</td></tr>
<tr class="memdesc:aeacbb6b7289fca260cf245602b992538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all elements of the satisfying set.  <br /></td></tr>
<tr class="separator:aeacbb6b7289fca260cf245602b992538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8565bc7d63b034daf7d82c43231aeb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aee8565bc7d63b034daf7d82c43231aeb">get_cofactor</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>, int32 varIndex, int32 varValue) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:aee8565bc7d63b034daf7d82c43231aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates cofactor of the functions.  <br /></td></tr>
<tr class="separator:aee8565bc7d63b034daf7d82c43231aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6beca04dc2c1d2ce2cdead99438f5d0"><td class="memItemLeft" align="right" valign="top"><a id="ac6beca04dc2c1d2ce2cdead99438f5d0" name="ac6beca04dc2c1d2ce2cdead99438f5d0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>get_cofactor</b> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>, std::vector&lt; <a class="el" href="structteddy_1_1var__cofactor.html">var_cofactor</a> &gt; const &amp;vars) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="separator:ac6beca04dc2c1d2ce2cdead99438f5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dfa020ac1cdd8d1ead5cae60629b5e"><td class="memTemplParams" colspan="2">template&lt;int_to_int F&gt; </td></tr>
<tr class="memitem:ad1dfa020ac1cdd8d1ead5cae60629b5e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ad1dfa020ac1cdd8d1ead5cae60629b5e">transform</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>, F transformer) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:ad1dfa020ac1cdd8d1ead5cae60629b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms values of the function.  <br /></td></tr>
<tr class="separator:ad1dfa020ac1cdd8d1ead5cae60629b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf0cfe0f05291e69a3678b4ad51c164"><td class="memTemplParams" colspan="2">template&lt;class Foo  = void&gt; <br />
requires (is_bdd&lt;Degree&gt;)</td></tr>
<tr class="memitem:a5cf0cfe0f05291e69a3678b4ad51c164"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a5cf0cfe0f05291e69a3678b4ad51c164">negate</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) -&gt; utils::second_t&lt; Foo, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:a5cf0cfe0f05291e69a3678b4ad51c164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates Boolean function.  <br /></td></tr>
<tr class="separator:a5cf0cfe0f05291e69a3678b4ad51c164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a106a4d96b6488fc97e6ed65c1ed76"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a27a106a4d96b6488fc97e6ed65c1ed76">get_dependency_set</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) const -&gt; std::vector&lt; int32 &gt;</td></tr>
<tr class="memdesc:a27a106a4d96b6488fc97e6ed65c1ed76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates indices of variables that the function depends on.  <br /></td></tr>
<tr class="separator:a27a106a4d96b6488fc97e6ed65c1ed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab708d79fce243ba775bd064f4fcb0043"><td class="memTemplParams" colspan="2">template&lt;std::output_iterator&lt; int32 &gt; O&gt; </td></tr>
<tr class="memitem:ab708d79fce243ba775bd064f4fcb0043"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ab708d79fce243ba775bd064f4fcb0043">get_dependency_set_g</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>, O out) const -&gt; void</td></tr>
<tr class="memdesc:ab708d79fce243ba775bd064f4fcb0043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates indices of variables that the function depends on.  <br /></td></tr>
<tr class="separator:ab708d79fce243ba775bd064f4fcb0043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26206b726aa6cbe678b7f841058870e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ab26206b726aa6cbe678b7f841058870e">reduce</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:ab26206b726aa6cbe678b7f841058870e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces diagrams to its canonical form.  <br /></td></tr>
<tr class="separator:ab26206b726aa6cbe678b7f841058870e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c85bee160986ba9db8700c788c8a13"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ad9c85bee160986ba9db8700c788c8a13">get_node_count</a> () const -&gt; int64</td></tr>
<tr class="memdesc:ad9c85bee160986ba9db8700c788c8a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of nodes that are currently used by the manager.  <br /></td></tr>
<tr class="separator:ad9c85bee160986ba9db8700c788c8a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c30d1083aae1d24eb3932a35ac2c432"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a3c30d1083aae1d24eb3932a35ac2c432">get_node_count</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) const -&gt; int64</td></tr>
<tr class="memdesc:a3c30d1083aae1d24eb3932a35ac2c432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of nodes in the diagram including terminal nodes.  <br /></td></tr>
<tr class="separator:a3c30d1083aae1d24eb3932a35ac2c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a02749d3a2902adb581b7b064a78064"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a9a02749d3a2902adb581b7b064a78064">to_dot_graph</a> (std::ostream &amp;out) const -&gt; void</td></tr>
<tr class="memdesc:a9a02749d3a2902adb581b7b064a78064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dot representation of the graph.  <br /></td></tr>
<tr class="separator:a9a02749d3a2902adb581b7b064a78064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e13bcf94b79b2f2b09aa0b5cc6bba03"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a9e13bcf94b79b2f2b09aa0b5cc6bba03">to_dot_graph</a> (std::ostream &amp;out, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>) const -&gt; void</td></tr>
<tr class="memdesc:a9e13bcf94b79b2f2b09aa0b5cc6bba03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dot representation of the diagram.  <br /></td></tr>
<tr class="separator:a9e13bcf94b79b2f2b09aa0b5cc6bba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c7741f43b3dee51ea32373b503c809"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a28c7741f43b3dee51ea32373b503c809">force_gc</a> () -&gt; void</td></tr>
<tr class="memdesc:a28c7741f43b3dee51ea32373b503c809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs garbage collection.  <br /></td></tr>
<tr class="separator:a28c7741f43b3dee51ea32373b503c809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf4949b9aa87dd65d0f91e95d66d0cb"><td class="memItemLeft" align="right" valign="top"><a id="aedf4949b9aa87dd65d0f91e95d66d0cb" name="aedf4949b9aa87dd65d0f91e95d66d0cb"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>force_reorder</b> () -&gt; void</td></tr>
<tr class="memdesc:aedf4949b9aa87dd65d0f91e95d66d0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs variable reordering heuristic. <br /></td></tr>
<tr class="separator:aedf4949b9aa87dd65d0f91e95d66d0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9d97bf105bf62b27ca55aee875b24f"><td class="memItemLeft" align="right" valign="top"><a id="aed9d97bf105bf62b27ca55aee875b24f" name="aed9d97bf105bf62b27ca55aee875b24f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>clear_cache</b> () -&gt; void</td></tr>
<tr class="memdesc:aed9d97bf105bf62b27ca55aee875b24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears apply cache. <br /></td></tr>
<tr class="separator:aed9d97bf105bf62b27ca55aee875b24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2244994cc18ed6b3a30e128834bb0202"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a2244994cc18ed6b3a30e128834bb0202">get_var_count</a> () const -&gt; int32</td></tr>
<tr class="memdesc:a2244994cc18ed6b3a30e128834bb0202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of variables for this manager set in the constructor.  <br /></td></tr>
<tr class="separator:a2244994cc18ed6b3a30e128834bb0202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab356a064a3356f3415c11025528ae502"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ab356a064a3356f3415c11025528ae502">get_order</a> () const -&gt; std::vector&lt; int32 &gt; const &amp;</td></tr>
<tr class="memdesc:ab356a064a3356f3415c11025528ae502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current order of variables.  <br /></td></tr>
<tr class="separator:ab356a064a3356f3415c11025528ae502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358b24b094b3206bc610147b3cd08881"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a358b24b094b3206bc610147b3cd08881">get_domains</a> () const -&gt; std::vector&lt; int32 &gt;</td></tr>
<tr class="memdesc:a358b24b094b3206bc610147b3cd08881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return domains of variables.  <br /></td></tr>
<tr class="separator:a358b24b094b3206bc610147b3cd08881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0">set_cache_ratio</a> (double ratio) -&gt; void</td></tr>
<tr class="memdesc:a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relative cache size w.r.t the number of nodes.  <br /></td></tr>
<tr class="separator:a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110856ce25c5aa8af6c36ffc3c753c97"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a110856ce25c5aa8af6c36ffc3c753c97">set_gc_ratio</a> (double ratio) -&gt; void</td></tr>
<tr class="memdesc:a110856ce25c5aa8af6c36ffc3c753c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ratio used to determine new node pool allocation.  <br /></td></tr>
<tr class="separator:a110856ce25c5aa8af6c36ffc3c753c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aa759504ba479d7e1c2d8103459444"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aa0aa759504ba479d7e1c2d8103459444">set_auto_reorder</a> (bool doReorder) -&gt; void</td></tr>
<tr class="memdesc:aa0aa759504ba479d7e1c2d8103459444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables automatic variable reordering.  <br /></td></tr>
<tr class="separator:aa0aa759504ba479d7e1c2d8103459444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a45ab5fc7ee433c3899982b2489b013"><td class="memItemLeft" align="right" valign="top"><a id="a4a45ab5fc7ee433c3899982b2489b013" name="a4a45ab5fc7ee433c3899982b2489b013"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>diagram_manager</b> (<a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a4a45ab5fc7ee433c3899982b2489b013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0588de7672a51db0ec6864aafd7f97a5"><td class="memItemLeft" align="right" valign="top"><a id="a0588de7672a51db0ec6864aafd7f97a5" name="a0588de7672a51db0ec6864aafd7f97a5"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> &amp;&amp;) noexcept -&gt; <a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> &amp;=default</td></tr>
<tr class="separator:a0588de7672a51db0ec6864aafd7f97a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12278af62ce8151192671d2524d314e8"><td class="memItemLeft" align="right" valign="top"><a id="a12278af62ce8151192671d2524d314e8" name="a12278af62ce8151192671d2524d314e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>diagram_manager</b> (<a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> const &amp;)=delete</td></tr>
<tr class="separator:a12278af62ce8151192671d2524d314e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775403b95e4a279d38c627174d2baec1"><td class="memItemLeft" align="right" valign="top"><a id="a775403b95e4a279d38c627174d2baec1" name="a775403b95e4a279d38c627174d2baec1"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> const &amp;) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> &amp;=delete</td></tr>
<tr class="separator:a775403b95e4a279d38c627174d2baec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e8fc66b4890fba23df39976ad4c468"><td class="memTemplParams" colspan="2"><a id="ac9e8fc66b4890fba23df39976ad4c468" name="ac9e8fc66b4890fba23df39976ad4c468"></a>
template&lt;out_var_values Vars, std::output_iterator&lt; Vars &gt; OutputIt&gt; </td></tr>
<tr class="memitem:ac9e8fc66b4890fba23df39976ad4c468"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>satisfy_all_g</b> (int32 const value, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;<a class="el" href="classteddy_1_1diagram.html">diagram</a>, OutputIt out) const -&gt; void</td></tr>
<tr class="separator:ac9e8fc66b4890fba23df39976ad4c468"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a6e5142fac56713fea1a5f9a1cb3d9235"><td class="memItemLeft" align="right" valign="top"><a id="a6e5142fac56713fea1a5f9a1cb3d9235" name="a6e5142fac56713fea1a5f9a1cb3d9235"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_t</b> = typename <a class="el" href="classteddy_1_1diagram.html">diagram</a>&lt; Data, Degree &gt;::node_t</td></tr>
<tr class="separator:a6e5142fac56713fea1a5f9a1cb3d9235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27649886cea4e867f796ee32d33f6193"><td class="memItemLeft" align="right" valign="top"><a id="a27649886cea4e867f796ee32d33f6193" name="a27649886cea4e867f796ee32d33f6193"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>son_container</b> = typename node_t::son_container</td></tr>
<tr class="separator:a27649886cea4e867f796ee32d33f6193"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a06ecd18ef086f5c9740036652e3ce63b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a06ecd18ef086f5c9740036652e3ce63b">diagram_manager</a> (int32 varCount, int64 nodePoolSize, int64 extraNodePoolSize, std::vector&lt; int32 &gt; order)</td></tr>
<tr class="memdesc:a06ecd18ef086f5c9740036652e3ce63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes diagram manager.  <br /></td></tr>
<tr class="separator:a06ecd18ef086f5c9740036652e3ce63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6319c0382392f0a84dac1fb55bd163"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a3a6319c0382392f0a84dac1fb55bd163">diagram_manager</a> (int32 varCount, int64 nodePoolSize, int64 extraNodePoolSize, <a class="el" href="structteddy_1_1domains_1_1mixed.html">domains::mixed</a> domain, std::vector&lt; int32 &gt; order)</td></tr>
<tr class="memdesc:a3a6319c0382392f0a84dac1fb55bd163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes diagram manager.  <br /></td></tr>
<tr class="separator:a3a6319c0382392f0a84dac1fb55bd163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab98034c8b05644fa852e15b2d08b18fb"><td class="memItemLeft" align="right" valign="top"><a id="ab98034c8b05644fa852e15b2d08b18fb" name="ab98034c8b05644fa852e15b2d08b18fb"></a>
<a class="el" href="classteddy_1_1node__manager.html">node_manager</a>&lt; Data, Degree, Domain &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes_</b></td></tr>
<tr class="separator:ab98034c8b05644fa852e15b2d08b18fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Data, class Degree, class Domain&gt;<br />
class teddy::diagram_manager&lt; Data, Degree, Domain &gt;</div><p>Base class for all diagram managers that generically implements all of the algorithms. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a06ecd18ef086f5c9740036652e3ce63b" name="a06ecd18ef086f5c9740036652e3ce63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ecd18ef086f5c9740036652e3ce63b">&#9670;&#160;</a></span>diagram_manager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; <br />
requires (<a class="el" href="structteddy_1_1domains_1_1is__fixed.html">domains::is_fixed</a>&lt;Domain&gt;::value)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::diagram_manager </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>varCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>nodePoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>extraNodePoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32 &gt;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes diagram manager. </p>
<p>This overload is for managers that have fixed domains (known at copile time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varCount</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">nodePoolSize</td><td>Number of nodes that is pre-allocated. </td></tr>
    <tr><td class="paramname">extraNodePoolSize</td><td>Size of the additional node pools. </td></tr>
    <tr><td class="paramname">order</td><td>Order of variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a6319c0382392f0a84dac1fb55bd163" name="a3a6319c0382392f0a84dac1fb55bd163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6319c0382392f0a84dac1fb55bd163">&#9670;&#160;</a></span>diagram_manager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; <br />
requires (<a class="el" href="structteddy_1_1domains_1_1is__mixed.html">domains::is_mixed</a>&lt;Domain&gt;::value)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::diagram_manager </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>varCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>nodePoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>extraNodePoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteddy_1_1domains_1_1mixed.html">domains::mixed</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32 &gt;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes diagram manager. </p>
<p>This overload is for managers that have mixed domains specified by the <code>ds</code> paramter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varCount</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">nodePoolSize</td><td>Number of nodes that is pre-allocated. </td></tr>
    <tr><td class="paramname">extraNodePoolSize</td><td>Size of the additional node pools. </td></tr>
    <tr><td class="paramname">ds</td><td>Domains of varibales. </td></tr>
    <tr><td class="paramname">order</td><td>Order of variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aae9b81bc96567b5e59b0ae4326e83d14" name="aae9b81bc96567b5e59b0ae4326e83d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9b81bc96567b5e59b0ae4326e83d14">&#9670;&#160;</a></span>constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::constant </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram representing constant function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value of the constant function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing constant function </dd></dl>

</div>
</div>
<a id="a7a825b2e44e0f2480b6cb272f8877661" name="a7a825b2e44e0f2480b6cb272f8877661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a825b2e44e0f2480b6cb272f8877661">&#9670;&#160;</a></span>variable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variable </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram representing function of single variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram of a function of single variable </dd></dl>

</div>
</div>
<a id="ad453049e900b8c4bc304737f40c7c098" name="ad453049e900b8c4bc304737f40c7c098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad453049e900b8c4bc304737f40c7c098">&#9670;&#160;</a></span>variable_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
<div class="memtemplate">
template&lt;class Foo &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variable_not </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> -&gt; utils::second_t&lt;Foo, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates BDD representing function of complemented variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram of a function of single variable </dd></dl>

</div>
</div>
<a id="ad7c971ef459dd59243445daafb142d01" name="ad7c971ef459dd59243445daafb142d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c971ef459dd59243445daafb142d01">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram representing function of single variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram of a function of single variable </dd></dl>

</div>
</div>
<a id="a96a278e6eeebcc1d87a0c1ee539e512e" name="a96a278e6eeebcc1d87a0c1ee539e512e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a278e6eeebcc1d87a0c1ee539e512e">&#9670;&#160;</a></span>variables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;std::convertible_to&lt; int32 &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variables </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> -&gt; std::vector&lt;<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates vector of diagrams representing single variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>integral type convertible to unsgined int </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>initializer list of indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of diagrams </dd></dl>

</div>
</div>
<a id="a80f56f39c209510b6602ab6863e30899" name="a80f56f39c209510b6602ab6863e30899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f56f39c209510b6602ab6863e30899">&#9670;&#160;</a></span>variables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variables </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::vector&lt;<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates vector of diagrams representing functions of single variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>iterator type for the input range. </td></tr>
    <tr><td class="paramname">S</td><td>sentinel type for <code>I</code> . (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element of range of indices represented by integral type convertible to unsgined int. </td></tr>
    <tr><td class="paramname">last</td><td>sentinel for <code>first</code> (end iterator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of diagrams. </dd></dl>

</div>
</div>
<a id="a88fa2f23c486004004e7655ee219121f" name="a88fa2f23c486004004e7655ee219121f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fa2f23c486004004e7655ee219121f">&#9670;&#160;</a></span>variables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variables </td>
          <td>(</td>
          <td class="paramtype">Is const &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> -&gt; std::vector&lt;<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates vector of diagrams representing single variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Is</td><td>range of integral indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>range of Ts (e.g. std::vector&lt;int&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of diagrams </dd></dl>

</div>
</div>
<a id="a926f78f0cea41fd1d3b0ab71d3ff732c" name="a926f78f0cea41fd1d3b0ab71d3ff732c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926f78f0cea41fd1d3b0ab71d3ff732c">&#9670;&#160;</a></span>from_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::from_vector </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram from a truth vector of a function. </p>
<p>Example for the function f(x) = max(x0, x1, x2): </p><div class="fragment"><div class="line"><span class="comment">// Truth table:</span></div>
<div class="line">+----+----+----+----+---+----+-----+----+---+</div>
<div class="line">| x1 | x2 | x3 | f  | _ | x1 |  x2 | x3 | f |</div>
<div class="line">+----+----+----+----+---+----+-----+----+---+</div>
<div class="line">| 0  | 0  | 0  | 0  |   | 1  |  0  | 0  | 1 |</div>
<div class="line">| 0  | 0  | 1  | 1  |   | 1  |  0  | 1  | 1 |</div>
<div class="line">| 0  | 0  | 2  | 2  |   | 1  |  0  | 2  | 2 |</div>
<div class="line">| 0  | 1  | 0  | 1  |   | 1  |  1  | 0  | 1 |</div>
<div class="line">| 0  | 1  | 1  | 1  |   | 1  |  1  | 1  | 1 |</div>
<div class="line">| 0  | 1  | 2  | 2  |   | 1  |  1  | 2  | 2 |</div>
<div class="line">+----+----+----+----+---+----+-----+----+---+</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Truth vector:</span></div>
<div class="line">[0 1 2 1 1 2 1 1 2 1 1 2]</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Teddy code:</span></div>
<div class="line"><a class="code hl_class" href="structteddy_1_1ifmdd__manager.html">teddy::ifmdd_manager&lt;3&gt;</a> manager(3, 100, {2, 2, 3});</div>
<div class="line">std::vector&lt;int&gt; vec {0, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2};</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> f = manager.from_vector(vec);</div>
<div class="ttc" id="aclassteddy_1_1diagram__manager_html_afd258af2e42689cd3887b7c7acd7c64a"><div class="ttname"><a href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">teddy::diagram_manager::diagram_t</a></div><div class="ttdeci">diagram&lt; Data, Degree &gt; diagram_t</div><div class="ttdoc">Alias for the diagram type used in the functions of this manager.</div><div class="ttdef"><b>Definition</b> diagram_manager.hpp:97</div></div>
<div class="ttc" id="astructteddy_1_1ifmdd__manager_html"><div class="ttname"><a href="structteddy_1_1ifmdd__manager.html">teddy::ifmdd_manager</a></div><div class="ttdoc">Diagram manager (integer) Multi-valued Decision Diagrams (iMDDs)</div><div class="ttdef"><b>Definition</b> core.hpp:149</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>Iterator type for the input range. </td></tr>
    <tr><td class="paramname">S</td><td>Sentinel type for <code>I</code> (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element of the truth vector </td></tr>
    <tr><td class="paramname">last</td><td>sentinel for <code>first</code> (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing function given by the truth vector </dd></dl>

</div>
</div>
<a id="a9669d1358d90dc81f5b7205589fd89bd" name="a9669d1358d90dc81f5b7205589fd89bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9669d1358d90dc81f5b7205589fd89bd">&#9670;&#160;</a></span>from_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::from_vector </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram from a truth vector of a function. </p>
<p>See the other overload for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Type of the range that contains the truth vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Range representing the truth vector Elements of the range must be convertible to int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing function given by the truth vector </dd></dl>

</div>
</div>
<a id="a42b38d2cfc763ec18460e285ae5fba79" name="a42b38d2cfc763ec18460e285ae5fba79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b38d2cfc763ec18460e285ae5fba79">&#9670;&#160;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em></td><td>)</td>
          <td> const -&gt; std::vector&lt;int32&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates truth vector from the diagram. </p>
<p>Significance of variables is the same as in the <code>from_vector</code> function i.e., variable on the last level of the diagram is least significant. The following assertion holds: </p><div class="fragment"><div class="line">assert(manager.from_vector(manager.to_vector(d)))</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of ints representing the truth vector </dd></dl>

</div>
</div>
<a id="aa6ac10a68e553087882a6ae18383bd8d" name="aa6ac10a68e553087882a6ae18383bd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ac10a68e553087882a6ae18383bd8d">&#9670;&#160;</a></span>to_vector_g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;std::output_iterator&lt; teddy::int32 &gt; O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::to_vector_g </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates truth vector from the diagram. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">O</td><td>Output iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram </td></tr>
    <tr><td class="paramname">out</td><td>Output iterator that is used to output the truth vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb509e477341e7f39c7dbc60ca2dfbb8" name="abb509e477341e7f39c7dbc60ca2dfbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb509e477341e7f39c7dbc60ca2dfbb8">&#9670;&#160;</a></span>from_pla()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
<div class="memtemplate">
template&lt;class Foo &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::from_pla </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1pla__file.html">pla_file</a> const &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fold_type&#160;</td>
          <td class="paramname"><em>foldType</em> = <code>fold_type::Tree</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; utils::second_t&lt;Foo, std::vector&lt;<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates BDDs defined by PLA file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Foo</td><td>Dummy template to enable SFINE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PLA file loaded in the instance of <code><a class="el" href="classteddy_1_1pla__file.html" title="Representation of a PLA file.">pla_file</a></code> class. </td></tr>
    <tr><td class="paramname">foldType</td><td>fold type used in diagram creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of diagrams. </dd></dl>

</div>
</div>
<a id="a5cc4407d2bb8e97961bdbddf53d21e3e" name="a5cc4407d2bb8e97961bdbddf53d21e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc4407d2bb8e97961bdbddf53d21e3e">&#9670;&#160;</a></span>from_expression_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;expression_node Node&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::from_expression_tree </td>
          <td>(</td>
          <td class="paramtype">Node const &amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram from an expression tree (AST). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node</td><td>Node type of the tree. Must provide API given by the concept. Required API might change in the future. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root of the expression tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing function defined by the expression. </dd></dl>

</div>
</div>
<a id="a4a8a9698ab261c0ed323e4743bce5678" name="a4a8a9698ab261c0ed323e4743bce5678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8a9698ab261c0ed323e4743bce5678">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;teddy_bin_op Op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two diagrams using given binary operation. </p>
<p>Binary operations are defined in the namespace <code>teddy::ops</code> . All availabe operations are listed in the following table: </p><div class="fragment"><div class="line">+-------------------+---------------------------------------+</div>
<div class="line">| Binary operation  |           Description                 |</div>
<div class="line">+-------------------+---------------------------------------+</div>
<div class="line">| AND               | Logical and. ^ $                      |</div>
<div class="line">| OR                | Logical or. ^ $                       |</div>
<div class="line">| XOR               | Logical xor. ^ $                      |</div>
<div class="line">| NAND              | Logical nand. ^ $                     |</div>
<div class="line">| NOR               | Logical nor. ^ $                      |</div>
<div class="line">| XNOR              | Logical xnor. ^ $                     |</div>
<div class="line">| IMPLIES           | Logical implication. ^ $              |</div>
<div class="line">| EQUAL_TO          | Equal to relation. ^                  |</div>
<div class="line">| NOT_EQUAL_TO      | Not equal to relation. ^              |</div>
<div class="line">| LESS              | Less than relation. ^                 |</div>
<div class="line">| LESS_EQUAL        | Less than or equal relation. ^        |</div>
<div class="line">| GREATER           | Greater than relation. ^              |</div>
<div class="line">| GREATER_EQUAL     | Greater than or equal relation. ^     |</div>
<div class="line">| MIN               | Minimum of two values.                |</div>
<div class="line">| MAX               | Maximum of two values.                |</div>
<div class="line">| PLUS&lt;M&gt;           | Modular addition: (a + b) mod M.      |</div>
<div class="line">| MULTIPLIES&lt;M&gt;     | Modular multiplication: (a * b) mod M.|</div>
<div class="line">+-------------------+---------------------------------------+</div>
<div class="line">^ 0 is false and 1 is true</div>
<div class="line">$ assumes that arguments are 0 or 1</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Examples:</span></div>
<div class="line">manager.<a class="code hl_function" href="classteddy_1_1diagram__manager.html#a4a8a9698ab261c0ed323e4743bce5678">apply</a>&lt;teddy::<a class="code hl_namespace" href="namespaceops.html">ops</a>::AND&gt;(bdd1, bdd2);</div>
<div class="line">manager.apply&lt;<a class="code hl_struct" href="structteddy_1_1ops_1_1PLUS.html">teddy::ops::PLUS&lt;4&gt;</a>&gt;(mdd1, mdd2);</div>
<div class="ttc" id="aclassteddy_1_1diagram__manager_html_a4a8a9698ab261c0ed323e4743bce5678"><div class="ttname"><a href="classteddy_1_1diagram__manager.html#a4a8a9698ab261c0ed323e4743bce5678">teddy::diagram_manager::apply</a></div><div class="ttdeci">auto apply(diagram_t const &amp;lhs, diagram_t const &amp;rhs) -&gt; diagram_t</div><div class="ttdoc">Merges two diagrams using given binary operation.</div><div class="ttdef"><b>Definition</b> diagram_manager.hpp:1190</div></div>
<div class="ttc" id="anamespaceops_html"><div class="ttname"><a href="namespaceops.html">ops</a></div><div class="ttdoc">Contains definitions of all binary operations for apply function.</div></div>
<div class="ttc" id="astructteddy_1_1ops_1_1PLUS_html"><div class="ttname"><a href="structteddy_1_1ops_1_1PLUS.html">teddy::ops::PLUS</a></div><div class="ttdef"><b>Definition</b> operators.hpp:255</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>first diagram </td></tr>
    <tr><td class="paramname">rhs</td><td>second diagram </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="af9bcef18a79702ade105fc8de1ac69cb" name="af9bcef18a79702ade105fc8de1ac69cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bcef18a79702ade105fc8de1ac69cb">&#9670;&#160;</a></span>left_fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;teddy_bin_op Op, std::ranges::input_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::left_fold </td>
          <td>(</td>
          <td class="paramtype">R const &amp;&#160;</td>
          <td class="paramname"><em>diagrams</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges diagams in the range using the <code>apply</code> function and binary operation. </p>
<p>Uses left fold order of evaluation (sequentially from the left).</p>
<div class="fragment"><div class="line"><span class="comment">// Example:</span></div>
<div class="line">std::vector&lt;diagram_t&gt; vs = manager.variables({0, 1, 2});</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> product = manager.left_fold&lt;teddy::ops&gt;(vs);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation </td></tr>
    <tr><td class="paramname">R</td><td>Range containing diagrams (e.g. std::vector&lt;diagram_t&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagrams</td><td>Input range of diagrams to be merged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of all diagrams from the range </dd></dl>

</div>
</div>
<a id="a9954a79a74936ba6494ec15c1cc517e3" name="a9954a79a74936ba6494ec15c1cc517e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9954a79a74936ba6494ec15c1cc517e3">&#9670;&#160;</a></span>left_fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;teddy_bin_op Op, std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::left_fold </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges diagams in the range using the <code>apply</code> function and binary operation. </p>
<p>Uses left fold order of evaluation (sequentially from the left).</p>
<div class="fragment"><div class="line"><span class="comment">// Example:</span></div>
<div class="line">std::vector&lt;diagram_t&gt; vs = manager.variables({0, 1, 2});</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> product = manager.left_fold&lt;teddy::ops&gt;(</div>
<div class="line">    vs.begin(), vs.end());</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation </td></tr>
    <tr><td class="paramname">I</td><td>Range iterator type </td></tr>
    <tr><td class="paramname">S</td><td>Sentinel type for <code>I</code> (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Input iterator to the first diagram </td></tr>
    <tr><td class="paramname">last</td><td>Sentinel for <code>first</code> (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of all diagrams from the range </dd></dl>

</div>
</div>
<a id="a7a7cc644478b9cc47858ba69fb38dc81" name="a7a7cc644478b9cc47858ba69fb38dc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7cc644478b9cc47858ba69fb38dc81">&#9670;&#160;</a></span>tree_fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;teddy_bin_op Op, std::ranges::random_access_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::tree_fold </td>
          <td>(</td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>diagrams</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges diagams in the range using the <code>apply</code> function and binary operation. </p>
<p>Uses tree fold order of evaluation ((d1 op d2) op (d3 op d4) ...) . Tree fold uses the input range <code>range</code> to store some intermediate results. <code>range</code> is left in valid but unspecified state.</p>
<div class="fragment"><div class="line"><span class="comment">// Example:</span></div>
<div class="line">std::vector&lt;diagram_t&gt; vs = manager.variables({0, 1, 2});</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> product = manager.tree_fold&lt;teddy::ops&gt;(vs);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation </td></tr>
    <tr><td class="paramname">R</td><td>Range containing diagrams (e.g. std::vector&lt;diagram_t&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagrams</td><td>Random access range of diagrams to be merged (e.g. std::vector) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of all diagrams from the range </dd></dl>

</div>
</div>
<a id="af84d0aa56905007fa98c48cd2b9f9ae0" name="af84d0aa56905007fa98c48cd2b9f9ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84d0aa56905007fa98c48cd2b9f9ae0">&#9670;&#160;</a></span>tree_fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;teddy_bin_op Op, std::random_access_iterator I, std::sentinel_for&lt; I &gt; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::tree_fold </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges diagams in the range using the <code>apply</code> function and binary operation. </p>
<p>Uses tree fold order of evaluation ((d1 op d2) op (d3 op d4) ...) . Tree fold uses the input range <code>range</code> to store some intermediate results. <code>range</code> is left in valid but unspecified state.</p>
<div class="fragment"><div class="line"><span class="comment">// Example:</span></div>
<div class="line">std::vector&lt;diagram_t&gt; vs = manager.variables({0, 1, 2});</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> product = manager.tree_fold&lt;teddy::ops&gt;(</div>
<div class="line">    vs.begin(), vs.end());</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation </td></tr>
    <tr><td class="paramname">I</td><td>Range iterator type </td></tr>
    <tr><td class="paramname">S</td><td>Sentinel type for <code>I</code> (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Random access iterator to the first diagram </td></tr>
    <tr><td class="paramname">last</td><td>Sentinel for <code>first</code> (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of all diagrams from the range </dd></dl>

</div>
</div>
<a id="ab3b10389b7f067f73252fecbbce0e4ad" name="ab3b10389b7f067f73252fecbbce0e4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b10389b7f067f73252fecbbce0e4ad">&#9670;&#160;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;in_var_values Vars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vars const &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; int32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates value of the function represented by the diagram. </p>
<p>Complexity is <code>O(n)</code> where <code>n</code> is the number of variables.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vars</td><td>Container type that defines operator[] and returns value convertible to int </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram </td></tr>
    <tr><td class="paramname">values</td><td>Container holding values of variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the function represented by <code>d</code> for variable values given in <code>vs</code> </dd></dl>

</div>
</div>
<a id="a5f4b2afdbaa516984c4fe9144432dfc6" name="a5f4b2afdbaa516984c4fe9144432dfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4b2afdbaa516984c4fe9144432dfc6">&#9670;&#160;</a></span>satisfy_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_count </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of variable assignments for which the functions evaluates to certain value. </p>
<p>Complexity is <code>O</code>(|d|) where <code>|d|</code> is the number of nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value of the function </td></tr>
    <tr><td class="paramname">diagram</td><td>Diagram representing the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of different variable assignments for which the the function represented by <code>d</code> evaluates to <code>val</code> </dd></dl>

</div>
</div>
<a id="aaa8de2bb90b83e16ac5e33400d3d9aef" name="aaa8de2bb90b83e16ac5e33400d3d9aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8de2bb90b83e16ac5e33400d3d9aef">&#9670;&#160;</a></span>satisfy_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;out_var_values Vars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_one </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::optional&lt;Vars&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds variable assignment for which diagram evaluates to <code>value</code>. </p>
<p>Complexity is <code>O</code>(|n|) where <code>|n|</code> is the number of nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value of the function </td></tr>
    <tr><td class="paramname">diagram</td><td>Diagram representing the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optinal containing variable assignment or std::nullopt if there is no such an assignment </dd></dl>

</div>
</div>
<a id="adc05f6a6eb33c0638fbad192a0c7eda3" name="adc05f6a6eb33c0638fbad192a0c7eda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc05f6a6eb33c0638fbad192a0c7eda3">&#9670;&#160;</a></span>satisfy_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;out_var_values Vars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_all </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; std::vector&lt;Vars&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all elements of the satisfying set. </p>
<p>Enumerates all elements of the satisfying set of the function i.e. variable assignments for which the function evaluates to certain value.</p>
<p>Complexity is <code>O</code>(n*|Sf|) where <code>|Sf|</code> is the size of the satisfying set and <code>n</code> is the number of variables. Please note that this is quite high for bigger functions and the computation will probably not finish in reasonable time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vars</td><td>Container type that defines <code>operator</code>[] and allows assigning integers, std::vector is also allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value of the function </td></tr>
    <tr><td class="paramname">diagram</td><td>Diagram representing the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of <code>Vars</code> </dd></dl>

</div>
</div>
<a id="aeacbb6b7289fca260cf245602b992538" name="aeacbb6b7289fca260cf245602b992538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacbb6b7289fca260cf245602b992538">&#9670;&#160;</a></span>satisfy_all_g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;out_var_values Vars, std::output_iterator&lt; Vars &gt; O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_all_g </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt;  void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all elements of the satisfying set. </p>
<p>Enumerates all elements of the satisfying set of the function i.e. variable assignments for which the function evaluates to certain value.</p>
<p>Complexity is <code>O</code>(n*|Sf|) where <code>|Sf|</code> is the size of the satisfying set and <code>n</code> is the number of variables. Please note that this is quite high for bigger functions and the computation will probably not finish in reasonable time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vars</td><td>Container type that defines <code>operator</code>[] and allows assigning integers. std::vector is also allowed. </td></tr>
    <tr><td class="paramname">O</td><td>Output iterator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value of the function </td></tr>
    <tr><td class="paramname">diagram</td><td>Diagram representing the function </td></tr>
    <tr><td class="paramname">out</td><td>Output iterator that is used to output instances of <code>Vars</code> . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee8565bc7d63b034daf7d82c43231aeb" name="aee8565bc7d63b034daf7d82c43231aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8565bc7d63b034daf7d82c43231aeb">&#9670;&#160;</a></span>get_cofactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_cofactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>varIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>varValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates cofactor of the functions. </p>
<p>Calculates cofactor of the function i.e. fixes value of the <code>i</code> th variable to the value <code>val</code> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram representing the function </td></tr>
    <tr><td class="paramname">varIndex</td><td>Index of the variable to be fixed </td></tr>
    <tr><td class="paramname">varValue</td><td>Value to which the <code>i</code> th varibale should be fixed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing cofactor of the function </dd></dl>

</div>
</div>
<a id="ad1dfa020ac1cdd8d1ead5cae60629b5e" name="ad1dfa020ac1cdd8d1ead5cae60629b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dfa020ac1cdd8d1ead5cae60629b5e">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;int_to_int F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>transformer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms values of the function. </p>
<div class="fragment"><div class="line"><span class="comment">// Example of the call with 4-valued MDD.</span></div>
<div class="line">manager.transform(<a class="code hl_class" href="classteddy_1_1diagram.html">diagram</a>, [](<span class="keywordtype">int</span> v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> 3 - v;</div>
<div class="line">});</div>
<div class="ttc" id="aclassteddy_1_1diagram_html"><div class="ttname"><a href="classteddy_1_1diagram.html">teddy::diagram</a></div><div class="ttdoc">Cheap wrapper for the internal diagram node type.</div><div class="ttdef"><b>Definition</b> diagram.hpp:20</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of the transformation function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram representing the function </td></tr>
    <tr><td class="paramname">transformer</td><td>Transformation function that is applied to values of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing transformed function </dd></dl>

</div>
</div>
<a id="a5cf0cfe0f05291e69a3678b4ad51c164" name="a5cf0cfe0f05291e69a3678b4ad51c164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf0cfe0f05291e69a3678b4ad51c164">&#9670;&#160;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
<div class="memtemplate">
template&lt;class Foo &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::negate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em></td><td>)</td>
          <td> -&gt; utils::second_t&lt;Foo, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates Boolean function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram representing the function </td></tr>
    <tr><td class="paramname">transformer</td><td>Transformation function that is applied to values of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing transformed function </dd></dl>

</div>
</div>
<a id="a27a106a4d96b6488fc97e6ed65c1ed76" name="a27a106a4d96b6488fc97e6ed65c1ed76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a106a4d96b6488fc97e6ed65c1ed76">&#9670;&#160;</a></span>get_dependency_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_dependency_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em></td><td>)</td>
          <td> const -&gt; std::vector&lt;int32&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates indices of variables that the function depends on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram representing the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of indices </dd></dl>

</div>
</div>
<a id="ab708d79fce243ba775bd064f4fcb0043" name="ab708d79fce243ba775bd064f4fcb0043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab708d79fce243ba775bd064f4fcb0043">&#9670;&#160;</a></span>get_dependency_set_g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
<div class="memtemplate">
template&lt;std::output_iterator&lt; int32 &gt; O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_dependency_set_g </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates indices of variables that the function depends on. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">O</td><td>Output iterator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram representing the function. </td></tr>
    <tr><td class="paramname">out</td><td>Output iterator that is used to output indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab26206b726aa6cbe678b7f841058870e" name="ab26206b726aa6cbe678b7f841058870e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26206b726aa6cbe678b7f841058870e">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces diagrams to its canonical form. </p>
<p>You probably won't need to call this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram in a reduced canonical form </dd></dl>

</div>
</div>
<a id="ad9c85bee160986ba9db8700c788c8a13" name="ad9c85bee160986ba9db8700c788c8a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c85bee160986ba9db8700c788c8a13">&#9670;&#160;</a></span>get_node_count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_node_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of nodes that are currently used by the manager. </p>
<p>This function returns number of nodes that are currently stored in the unique tables. Total number of allocated nodes might and probably will be higher. See implementation details on github for details.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of nodes </dd></dl>

</div>
</div>
<a id="a3c30d1083aae1d24eb3932a35ac2c432" name="a3c30d1083aae1d24eb3932a35ac2c432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c30d1083aae1d24eb3932a35ac2c432">&#9670;&#160;</a></span>get_node_count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_node_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em></td><td>)</td>
          <td> const -&gt; int64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of nodes in the diagram including terminal nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagram</td><td>Diagram </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of node </dd></dl>

</div>
</div>
<a id="a9a02749d3a2902adb581b7b064a78064" name="a9a02749d3a2902adb581b7b064a78064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a02749d3a2902adb581b7b064a78064">&#9670;&#160;</a></span>to_dot_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::to_dot_graph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints dot representation of the graph. </p>
<p>Prints dot representation of the entire multi rooted graph to the output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output stream (e.g. <code>std::cout</code> or <code>std::ofstream</code> ) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e13bcf94b79b2f2b09aa0b5cc6bba03" name="a9e13bcf94b79b2f2b09aa0b5cc6bba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e13bcf94b79b2f2b09aa0b5cc6bba03">&#9670;&#160;</a></span>to_dot_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::to_dot_graph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>diagram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints dot representation of the diagram. </p>
<p>Prints dot representation of the diagram to the output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output stream (e.g. <code>std::cout</code> or <code>std::ofstream</code> ) </td></tr>
    <tr><td class="paramname">diagram</td><td>Diagram </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28c7741f43b3dee51ea32373b503c809" name="a28c7741f43b3dee51ea32373b503c809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c7741f43b3dee51ea32373b503c809">&#9670;&#160;</a></span>force_gc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::force_gc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs garbage collection. </p>
<p>Forces the garbage collection to run which removes nodes that are not referenced from the unique tables. These nodes, however, are not deallocated. See implementation details on github for details. GC is run automatically so you probably won't need to run this function yourself. </p>

</div>
</div>
<a id="a2244994cc18ed6b3a30e128834bb0202" name="a2244994cc18ed6b3a30e128834bb0202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2244994cc18ed6b3a30e128834bb0202">&#9670;&#160;</a></span>get_var_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_var_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of variables for this manager set in the constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of variables. </dd></dl>

</div>
</div>
<a id="ab356a064a3356f3415c11025528ae502" name="ab356a064a3356f3415c11025528ae502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab356a064a3356f3415c11025528ae502">&#9670;&#160;</a></span>get_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_order</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current order of variables. </p>
<p>If no sifting was performed in between call to the constructor and call to this function then the order is the same as specified in the constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of indices. Index at l-th position is the index of variable at l-th level of the diagram. </dd></dl>

</div>
</div>
<a id="a358b24b094b3206bc610147b3cd08881" name="a358b24b094b3206bc610147b3cd08881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358b24b094b3206bc610147b3cd08881">&#9670;&#160;</a></span>get_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_domains</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return domains of variables. </p>
<p>In case of <code><a class="el" href="structteddy_1_1bdd__manager.html" title="Diagram manager for Binary Decision Diagrams.">bdd_manager</a></code> and <code><a class="el" href="structteddy_1_1mdd__manager.html" title="Diagram manager for Multi-valued Decision Diagrams.">mdd_manager</a></code> domains of each variable is the same i.e. 2 or P. In case of <code><a class="el" href="structteddy_1_1imdd__manager.html" title="Diagram manager for (integer) Multi-valued Decision Diagrams (iMDDs)">imdd_manager</a></code> and <code><a class="el" href="structteddy_1_1ifmdd__manager.html" title="Diagram manager (integer) Multi-valued Decision Diagrams (iMDDs)">ifmdd_manager</a></code> the domains are the same as set in the constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of domains. </dd></dl>

</div>
</div>
<a id="a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0" name="a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0">&#9670;&#160;</a></span>set_cache_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::set_cache_ratio </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the relative cache size w.r.t the number of nodes. </p>
<p>Size of the cache is calculated as: </p><div class="fragment"><div class="line">ratio * uniqueNodeCount</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Number from the interval (0,oo) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a110856ce25c5aa8af6c36ffc3c753c97" name="a110856ce25c5aa8af6c36ffc3c753c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110856ce25c5aa8af6c36ffc3c753c97">&#9670;&#160;</a></span>set_gc_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::set_gc_ratio </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets ratio used to determine new node pool allocation. </p>
<p>New pool is allocated if: </p><div class="fragment"><div class="line">garbageCollectedNodes &lt; ratio * initNodeCount</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Number from the interval [0,1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0aa759504ba479d7e1c2d8103459444" name="aa0aa759504ba479d7e1c2d8103459444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aa759504ba479d7e1c2d8103459444">&#9670;&#160;</a></span>set_auto_reorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , class Degree , class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::set_auto_reorder </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doReorder</em></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables automatic variable reordering. </p>
<p>Note that when automatic reordering is enabled the manager can't guarantee that all diagrams will remain canonical. To ensure that a diagram <code>d</code> is canonical (e.g. to compare two functions), you need to call <code>reduce</code> on them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doReorder</td><td>Specifies whether to disable (false) or enable (true) automatic reordering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="diagram__manager_8hpp_source.html">diagram_manager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 23 2023 09:35:20 for TeDDy by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
