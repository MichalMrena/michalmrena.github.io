<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TeDDy: teddy::diagram_manager&lt; Data, Degree, Domain &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TeDDy<span id="projectnumber">&#160;3.0</span>
   </div>
   <div id="projectbrief">Decision diagram library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>teddy</b></li><li class="navelem"><a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classteddy_1_1diagram__manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">teddy::diagram_manager&lt; Data, Degree, Domain &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for all diagram managers that generically implements all of the algorithms.  
 <a href="classteddy_1_1diagram__manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="diagram__manager_8hpp_source.html">diagram_manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afd258af2e42689cd3887b7c7acd7c64a"><td class="memItemLeft" align="right" valign="top"><a id="afd258af2e42689cd3887b7c7acd7c64a" name="afd258af2e42689cd3887b7c7acd7c64a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>diagram_t</b> = <a class="el" href="classteddy_1_1diagram.html">diagram</a>&lt; Data, Degree &gt;</td></tr>
<tr class="memdesc:afd258af2e42689cd3887b7c7acd7c64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the diagram type used in the functions of this manager. <br /></td></tr>
<tr class="separator:afd258af2e42689cd3887b7c7acd7c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e5541e448620e4e39eb9f0314a5276d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a8e5541e448620e4e39eb9f0314a5276d">constant</a> (uint_t v) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a8e5541e448620e4e39eb9f0314a5276d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram representing constant function.  <a href="classteddy_1_1diagram__manager.html#a8e5541e448620e4e39eb9f0314a5276d">More...</a><br /></td></tr>
<tr class="separator:a8e5541e448620e4e39eb9f0314a5276d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b279ab997be99c116f6a38d20200e9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a53b279ab997be99c116f6a38d20200e9">variable</a> (index_t i) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a53b279ab997be99c116f6a38d20200e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram representing function of single variable.  <a href="classteddy_1_1diagram__manager.html#a53b279ab997be99c116f6a38d20200e9">More...</a><br /></td></tr>
<tr class="separator:a53b279ab997be99c116f6a38d20200e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4505f796689fd32385ddae310e8d9843"><td class="memTemplParams" colspan="2">template&lt;class Foo  = void&gt; <br />
requires (is_bdd&lt;Degree&gt;)</td></tr>
<tr class="memitem:a4505f796689fd32385ddae310e8d9843"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a4505f796689fd32385ddae310e8d9843">variable_not</a> (index_t i) -&gt; second_t&lt; Foo, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:a4505f796689fd32385ddae310e8d9843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates BDD representing function of complemented variable.  <a href="classteddy_1_1diagram__manager.html#a4505f796689fd32385ddae310e8d9843">More...</a><br /></td></tr>
<tr class="separator:a4505f796689fd32385ddae310e8d9843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd754f605dfcab429b6f1d857076219"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#accd754f605dfcab429b6f1d857076219">operator()</a> (index_t) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:accd754f605dfcab429b6f1d857076219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram representing function of single variable.  <a href="classteddy_1_1diagram__manager.html#accd754f605dfcab429b6f1d857076219">More...</a><br /></td></tr>
<tr class="separator:accd754f605dfcab429b6f1d857076219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9f8421cd7f33c11f6487e81683c7a1"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; index_t &gt; T&gt; </td></tr>
<tr class="memitem:a1f9f8421cd7f33c11f6487e81683c7a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a1f9f8421cd7f33c11f6487e81683c7a1">variables</a> (std::initializer_list&lt; T &gt; is) -&gt; std::vector&lt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:a1f9f8421cd7f33c11f6487e81683c7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates vector of diagrams representing functions of single variables.  <a href="classteddy_1_1diagram__manager.html#a1f9f8421cd7f33c11f6487e81683c7a1">More...</a><br /></td></tr>
<tr class="separator:a1f9f8421cd7f33c11f6487e81683c7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f56f39c209510b6602ab6863e30899"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </td></tr>
<tr class="memitem:a80f56f39c209510b6602ab6863e30899"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a80f56f39c209510b6602ab6863e30899">variables</a> (I first, S last) -&gt; std::vector&lt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:a80f56f39c209510b6602ab6863e30899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates vector of diagrams representing functions of single variables.  <a href="classteddy_1_1diagram__manager.html#a80f56f39c209510b6602ab6863e30899">More...</a><br /></td></tr>
<tr class="separator:a80f56f39c209510b6602ab6863e30899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae647e6868fb5c739e5646635d5523562"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range Is&gt; </td></tr>
<tr class="memitem:ae647e6868fb5c739e5646635d5523562"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ae647e6868fb5c739e5646635d5523562">variables</a> (Is const &amp;is) -&gt; std::vector&lt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt;</td></tr>
<tr class="memdesc:ae647e6868fb5c739e5646635d5523562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates vector of diagrams representing functions of single variables.  <a href="classteddy_1_1diagram__manager.html#ae647e6868fb5c739e5646635d5523562">More...</a><br /></td></tr>
<tr class="separator:ae647e6868fb5c739e5646635d5523562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926f78f0cea41fd1d3b0ab71d3ff732c"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </td></tr>
<tr class="memitem:a926f78f0cea41fd1d3b0ab71d3ff732c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a926f78f0cea41fd1d3b0ab71d3ff732c">from_vector</a> (I first, S last) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a926f78f0cea41fd1d3b0ab71d3ff732c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram from a truth vector of a function.  <a href="classteddy_1_1diagram__manager.html#a926f78f0cea41fd1d3b0ab71d3ff732c">More...</a><br /></td></tr>
<tr class="separator:a926f78f0cea41fd1d3b0ab71d3ff732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669d1358d90dc81f5b7205589fd89bd"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range R&gt; </td></tr>
<tr class="memitem:a9669d1358d90dc81f5b7205589fd89bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a9669d1358d90dc81f5b7205589fd89bd">from_vector</a> (R &amp;&amp;vector) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a9669d1358d90dc81f5b7205589fd89bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates diagram from a truth vector of a function.  <a href="classteddy_1_1diagram__manager.html#a9669d1358d90dc81f5b7205589fd89bd">More...</a><br /></td></tr>
<tr class="separator:a9669d1358d90dc81f5b7205589fd89bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eebd0c962003f434168e5ef3a3fc621"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a6eebd0c962003f434168e5ef3a3fc621">to_vector</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d) const -&gt; std::vector&lt; uint_t &gt;</td></tr>
<tr class="memdesc:a6eebd0c962003f434168e5ef3a3fc621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates truth vector from the diagram.  <a href="classteddy_1_1diagram__manager.html#a6eebd0c962003f434168e5ef3a3fc621">More...</a><br /></td></tr>
<tr class="separator:a6eebd0c962003f434168e5ef3a3fc621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c97c0ed2c5560d5b568b5b02d95055a"><td class="memTemplParams" colspan="2">template&lt;std::output_iterator&lt; uint_t &gt; O&gt; </td></tr>
<tr class="memitem:a1c97c0ed2c5560d5b568b5b02d95055a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a1c97c0ed2c5560d5b568b5b02d95055a">to_vector_g</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d, O out) const -&gt; void</td></tr>
<tr class="memdesc:a1c97c0ed2c5560d5b568b5b02d95055a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates truth vector from the diagram.  <a href="classteddy_1_1diagram__manager.html#a1c97c0ed2c5560d5b568b5b02d95055a">More...</a><br /></td></tr>
<tr class="separator:a1c97c0ed2c5560d5b568b5b02d95055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1553a94121ed1941075723197cc3cde"><td class="memTemplParams" colspan="2">template&lt;class Foo  = void&gt; <br />
requires (is_bdd&lt;Degree&gt;)</td></tr>
<tr class="memitem:aa1553a94121ed1941075723197cc3cde"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aa1553a94121ed1941075723197cc3cde">from_pla</a> (<a class="el" href="classteddy_1_1pla__file.html">pla_file</a> const &amp;file, fold_type foldType=fold_type::Tree) -&gt; second_t&lt; Foo, std::vector&lt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &gt; &gt;</td></tr>
<tr class="memdesc:aa1553a94121ed1941075723197cc3cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates BDDs defined by PLA file.  <a href="classteddy_1_1diagram__manager.html#aa1553a94121ed1941075723197cc3cde">More...</a><br /></td></tr>
<tr class="separator:aa1553a94121ed1941075723197cc3cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7372fbb53300004d2649862174fca1ab"><td class="memTemplParams" colspan="2">template&lt;bin_op Op&gt; </td></tr>
<tr class="memitem:a7372fbb53300004d2649862174fca1ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a7372fbb53300004d2649862174fca1ab">apply</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> l, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> r) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a7372fbb53300004d2649862174fca1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two diagrams using given binary operation.  <a href="classteddy_1_1diagram__manager.html#a7372fbb53300004d2649862174fca1ab">More...</a><br /></td></tr>
<tr class="separator:a7372fbb53300004d2649862174fca1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fe617cf5cc1872e36fd0dca87a7e85"><td class="memTemplParams" colspan="2">template&lt;bin_op Op, std::ranges::input_range R&gt; </td></tr>
<tr class="memitem:a97fe617cf5cc1872e36fd0dca87a7e85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a97fe617cf5cc1872e36fd0dca87a7e85">left_fold</a> (R const &amp;range) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a97fe617cf5cc1872e36fd0dca87a7e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges diagams in the range using the <code>apply</code> function and binary operation.  <a href="classteddy_1_1diagram__manager.html#a97fe617cf5cc1872e36fd0dca87a7e85">More...</a><br /></td></tr>
<tr class="separator:a97fe617cf5cc1872e36fd0dca87a7e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9954a79a74936ba6494ec15c1cc517e3"><td class="memTemplParams" colspan="2">template&lt;bin_op Op, std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </td></tr>
<tr class="memitem:a9954a79a74936ba6494ec15c1cc517e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a9954a79a74936ba6494ec15c1cc517e3">left_fold</a> (I first, S last) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a9954a79a74936ba6494ec15c1cc517e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges diagams in the range using the <code>apply</code> function and binary operation.  <a href="classteddy_1_1diagram__manager.html#a9954a79a74936ba6494ec15c1cc517e3">More...</a><br /></td></tr>
<tr class="separator:a9954a79a74936ba6494ec15c1cc517e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366cfc607825c26e5bacc8eba2a3eebe"><td class="memTemplParams" colspan="2">template&lt;bin_op Op, std::ranges::random_access_range R&gt; </td></tr>
<tr class="memitem:a366cfc607825c26e5bacc8eba2a3eebe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a366cfc607825c26e5bacc8eba2a3eebe">tree_fold</a> (R &amp;range) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a366cfc607825c26e5bacc8eba2a3eebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges diagams in the range using the <code>apply</code> function and binary operation.  <a href="classteddy_1_1diagram__manager.html#a366cfc607825c26e5bacc8eba2a3eebe">More...</a><br /></td></tr>
<tr class="separator:a366cfc607825c26e5bacc8eba2a3eebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84d0aa56905007fa98c48cd2b9f9ae0"><td class="memTemplParams" colspan="2">template&lt;bin_op Op, std::random_access_iterator I, std::sentinel_for&lt; I &gt; S&gt; </td></tr>
<tr class="memitem:af84d0aa56905007fa98c48cd2b9f9ae0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#af84d0aa56905007fa98c48cd2b9f9ae0">tree_fold</a> (I first, S last) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:af84d0aa56905007fa98c48cd2b9f9ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges diagams in the range using the <code>apply</code> function and binary operation.  <a href="classteddy_1_1diagram__manager.html#af84d0aa56905007fa98c48cd2b9f9ae0">More...</a><br /></td></tr>
<tr class="separator:af84d0aa56905007fa98c48cd2b9f9ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7afec0efb73cfc5f04fd8b936944e2"><td class="memTemplParams" colspan="2">template&lt;in_var_values Vars&gt; </td></tr>
<tr class="memitem:ade7afec0efb73cfc5f04fd8b936944e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ade7afec0efb73cfc5f04fd8b936944e2">evaluate</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d, Vars const &amp;vs) const -&gt; uint_t</td></tr>
<tr class="memdesc:ade7afec0efb73cfc5f04fd8b936944e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates value of the function represented by the diagram.  <a href="classteddy_1_1diagram__manager.html#ade7afec0efb73cfc5f04fd8b936944e2">More...</a><br /></td></tr>
<tr class="separator:ade7afec0efb73cfc5f04fd8b936944e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666b0ee69571cb6e25f1600ba157824"><td class="memTemplParams" colspan="2">template&lt;class Foo  = void&gt; <br />
requires (is_bdd&lt;Degree&gt;)</td></tr>
<tr class="memitem:a3666b0ee69571cb6e25f1600ba157824"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a3666b0ee69571cb6e25f1600ba157824">satisfy_count</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &amp;d) -&gt; second_t&lt; Foo, std::size_t &gt;</td></tr>
<tr class="memdesc:a3666b0ee69571cb6e25f1600ba157824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of variable assignments for which the functions evaluates to 1.  <a href="classteddy_1_1diagram__manager.html#a3666b0ee69571cb6e25f1600ba157824">More...</a><br /></td></tr>
<tr class="separator:a3666b0ee69571cb6e25f1600ba157824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa0e1f258555c41e9de4462b55f20be"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a6aa0e1f258555c41e9de4462b55f20be">satisfy_count</a> (uint_t val, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &amp;d) -&gt; std::size_t</td></tr>
<tr class="memdesc:a6aa0e1f258555c41e9de4462b55f20be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of variable assignments for which the functions evaluates to certain value.  <a href="classteddy_1_1diagram__manager.html#a6aa0e1f258555c41e9de4462b55f20be">More...</a><br /></td></tr>
<tr class="separator:a6aa0e1f258555c41e9de4462b55f20be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2a625d7e1dd9c993c80f7726158d78"><td class="memTemplParams" colspan="2">template&lt;out_var_values Vars, class Foo  = void&gt; <br />
requires (is_bdd&lt;Degree&gt;)</td></tr>
<tr class="memitem:a6a2a625d7e1dd9c993c80f7726158d78"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a6a2a625d7e1dd9c993c80f7726158d78">satisfy_all</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d) const -&gt; second_t&lt; Foo, std::vector&lt; Vars &gt; &gt;</td></tr>
<tr class="memdesc:a6a2a625d7e1dd9c993c80f7726158d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all elements of the satisfying set.  <a href="classteddy_1_1diagram__manager.html#a6a2a625d7e1dd9c993c80f7726158d78">More...</a><br /></td></tr>
<tr class="separator:a6a2a625d7e1dd9c993c80f7726158d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c60c0ef84d8eddb56b43e209ce10b9"><td class="memTemplParams" colspan="2">template&lt;out_var_values Vars&gt; </td></tr>
<tr class="memitem:a22c60c0ef84d8eddb56b43e209ce10b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a22c60c0ef84d8eddb56b43e209ce10b9">satisfy_all</a> (uint_t val, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d) const -&gt; std::vector&lt; Vars &gt;</td></tr>
<tr class="memdesc:a22c60c0ef84d8eddb56b43e209ce10b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all elements of the satisfying set.  <a href="classteddy_1_1diagram__manager.html#a22c60c0ef84d8eddb56b43e209ce10b9">More...</a><br /></td></tr>
<tr class="separator:a22c60c0ef84d8eddb56b43e209ce10b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dafd546c07f0c5821370788c7c5f09e"><td class="memTemplParams" colspan="2">template&lt;out_var_values Vars, std::output_iterator&lt; Vars &gt; O&gt; </td></tr>
<tr class="memitem:a9dafd546c07f0c5821370788c7c5f09e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a9dafd546c07f0c5821370788c7c5f09e">satisfy_all_g</a> (uint_t val, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d, O out) const -&gt; void</td></tr>
<tr class="memdesc:a9dafd546c07f0c5821370788c7c5f09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all elements of the satisfying set.  <a href="classteddy_1_1diagram__manager.html#a9dafd546c07f0c5821370788c7c5f09e">More...</a><br /></td></tr>
<tr class="separator:a9dafd546c07f0c5821370788c7c5f09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94a0de0c119b2fa40256dd24505f64a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ac94a0de0c119b2fa40256dd24505f64a">cofactor</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d, index_t i, uint_t val) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:ac94a0de0c119b2fa40256dd24505f64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates cofactor of the functions.  <a href="classteddy_1_1diagram__manager.html#ac94a0de0c119b2fa40256dd24505f64a">More...</a><br /></td></tr>
<tr class="separator:ac94a0de0c119b2fa40256dd24505f64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759640699bb5baad483f4cb0bd595e39"><td class="memTemplParams" colspan="2">template&lt;uint_to_bool F&gt; </td></tr>
<tr class="memitem:a759640699bb5baad483f4cb0bd595e39"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a759640699bb5baad483f4cb0bd595e39">transform</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d, F f=utils::not_zero) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:a759640699bb5baad483f4cb0bd595e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms values of the function.  <a href="classteddy_1_1diagram__manager.html#a759640699bb5baad483f4cb0bd595e39">More...</a><br /></td></tr>
<tr class="separator:a759640699bb5baad483f4cb0bd595e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece176e6e8455a888e45aee9ccdadde3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aece176e6e8455a888e45aee9ccdadde3">dependency_set</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d) const -&gt; std::vector&lt; index_t &gt;</td></tr>
<tr class="memdesc:aece176e6e8455a888e45aee9ccdadde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates indices of variables that the function depends on.  <a href="classteddy_1_1diagram__manager.html#aece176e6e8455a888e45aee9ccdadde3">More...</a><br /></td></tr>
<tr class="separator:aece176e6e8455a888e45aee9ccdadde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe950a01ddd987306e62ab994514987"><td class="memTemplParams" colspan="2">template&lt;std::output_iterator&lt; index_t &gt; O&gt; </td></tr>
<tr class="memitem:a2fe950a01ddd987306e62ab994514987"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a2fe950a01ddd987306e62ab994514987">dependency_set_g</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d, O out) const -&gt; void</td></tr>
<tr class="memdesc:a2fe950a01ddd987306e62ab994514987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates indices of variables that the function depends on.  <a href="classteddy_1_1diagram__manager.html#a2fe950a01ddd987306e62ab994514987">More...</a><br /></td></tr>
<tr class="separator:a2fe950a01ddd987306e62ab994514987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a3909fd675c908faa256db43d8049c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#aa5a3909fd675c908faa256db43d8049c">reduce</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td></tr>
<tr class="memdesc:aa5a3909fd675c908faa256db43d8049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces diagrams to its canonical form.  <a href="classteddy_1_1diagram__manager.html#aa5a3909fd675c908faa256db43d8049c">More...</a><br /></td></tr>
<tr class="separator:aa5a3909fd675c908faa256db43d8049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df9c68f93bd16f27f48503a8c2f2652"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a0df9c68f93bd16f27f48503a8c2f2652">node_count</a> () const -&gt; std::size_t</td></tr>
<tr class="memdesc:a0df9c68f93bd16f27f48503a8c2f2652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of nodes that are currently used by the manager.  <a href="classteddy_1_1diagram__manager.html#a0df9c68f93bd16f27f48503a8c2f2652">More...</a><br /></td></tr>
<tr class="separator:a0df9c68f93bd16f27f48503a8c2f2652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d0b80624848f04953e24fc2b39c34d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a65d0b80624848f04953e24fc2b39c34d">node_count</a> (<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d) const -&gt; std::size_t</td></tr>
<tr class="memdesc:a65d0b80624848f04953e24fc2b39c34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of nodes in the diagram including terminal nodes.  <a href="classteddy_1_1diagram__manager.html#a65d0b80624848f04953e24fc2b39c34d">More...</a><br /></td></tr>
<tr class="separator:a65d0b80624848f04953e24fc2b39c34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a02749d3a2902adb581b7b064a78064"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a9a02749d3a2902adb581b7b064a78064">to_dot_graph</a> (std::ostream &amp;out) const -&gt; void</td></tr>
<tr class="memdesc:a9a02749d3a2902adb581b7b064a78064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dot representation of the graph.  <a href="classteddy_1_1diagram__manager.html#a9a02749d3a2902adb581b7b064a78064">More...</a><br /></td></tr>
<tr class="separator:a9a02749d3a2902adb581b7b064a78064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8ddc5bdd085e17a7fd7bb1cc9e7f4f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a8b8ddc5bdd085e17a7fd7bb1cc9e7f4f">to_dot_graph</a> (std::ostream &amp;out, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> d) const -&gt; void</td></tr>
<tr class="memdesc:a8b8ddc5bdd085e17a7fd7bb1cc9e7f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dot representation of the diagram.  <a href="classteddy_1_1diagram__manager.html#a8b8ddc5bdd085e17a7fd7bb1cc9e7f4f">More...</a><br /></td></tr>
<tr class="separator:a8b8ddc5bdd085e17a7fd7bb1cc9e7f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf99b292c8f0e9a77e3c9559aac81e1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a7cf99b292c8f0e9a77e3c9559aac81e1">gc</a> () -&gt; void</td></tr>
<tr class="memdesc:a7cf99b292c8f0e9a77e3c9559aac81e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs garbage collection.  <a href="classteddy_1_1diagram__manager.html#a7cf99b292c8f0e9a77e3c9559aac81e1">More...</a><br /></td></tr>
<tr class="separator:a7cf99b292c8f0e9a77e3c9559aac81e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745059ebf952a92062988a212a19221e"><td class="memItemLeft" align="right" valign="top"><a id="a745059ebf952a92062988a212a19221e" name="a745059ebf952a92062988a212a19221e"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>sift</b> () -&gt; void</td></tr>
<tr class="memdesc:a745059ebf952a92062988a212a19221e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs variable sifting algorithm that tries to minimize number of nodes. <br /></td></tr>
<tr class="separator:a745059ebf952a92062988a212a19221e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384f1b204158d92c60fc90cc91bc3084"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a384f1b204158d92c60fc90cc91bc3084">get_var_count</a> () const -&gt; std::size_t</td></tr>
<tr class="memdesc:a384f1b204158d92c60fc90cc91bc3084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of variables for this manager set in the constructor.  <a href="classteddy_1_1diagram__manager.html#a384f1b204158d92c60fc90cc91bc3084">More...</a><br /></td></tr>
<tr class="separator:a384f1b204158d92c60fc90cc91bc3084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961fea54d7c7ccefb2dee2bb6e0d155f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a961fea54d7c7ccefb2dee2bb6e0d155f">get_order</a> () const -&gt; std::vector&lt; index_t &gt; const &amp;</td></tr>
<tr class="memdesc:a961fea54d7c7ccefb2dee2bb6e0d155f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current order of variables.  <a href="classteddy_1_1diagram__manager.html#a961fea54d7c7ccefb2dee2bb6e0d155f">More...</a><br /></td></tr>
<tr class="separator:a961fea54d7c7ccefb2dee2bb6e0d155f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046100716dc71e5d9f2fb08b66c6101b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a046100716dc71e5d9f2fb08b66c6101b">get_domains</a> () const -&gt; std::vector&lt; uint_t &gt;</td></tr>
<tr class="memdesc:a046100716dc71e5d9f2fb08b66c6101b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return domains of variables.  <a href="classteddy_1_1diagram__manager.html#a046100716dc71e5d9f2fb08b66c6101b">More...</a><br /></td></tr>
<tr class="separator:a046100716dc71e5d9f2fb08b66c6101b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0">set_cache_ratio</a> (double ratio) -&gt; void</td></tr>
<tr class="memdesc:a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relative cache size w.r.t the number of nodes.  <a href="classteddy_1_1diagram__manager.html#a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0">More...</a><br /></td></tr>
<tr class="separator:a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110856ce25c5aa8af6c36ffc3c753c97"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a110856ce25c5aa8af6c36ffc3c753c97">set_gc_ratio</a> (double ratio) -&gt; void</td></tr>
<tr class="memdesc:a110856ce25c5aa8af6c36ffc3c753c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ratio used to determine new node pool allocation.  <a href="classteddy_1_1diagram__manager.html#a110856ce25c5aa8af6c36ffc3c753c97">More...</a><br /></td></tr>
<tr class="separator:a110856ce25c5aa8af6c36ffc3c753c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12278af62ce8151192671d2524d314e8"><td class="memItemLeft" align="right" valign="top"><a id="a12278af62ce8151192671d2524d314e8" name="a12278af62ce8151192671d2524d314e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>diagram_manager</b> (<a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> const &amp;)=delete</td></tr>
<tr class="separator:a12278af62ce8151192671d2524d314e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5657a6fc1457f3d25c3f329765c09d96"><td class="memItemLeft" align="right" valign="top"><a id="a5657a6fc1457f3d25c3f329765c09d96" name="a5657a6fc1457f3d25c3f329765c09d96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>diagram_manager</b> (<a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a5657a6fc1457f3d25c3f329765c09d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775403b95e4a279d38c627174d2baec1"><td class="memItemLeft" align="right" valign="top"><a id="a775403b95e4a279d38c627174d2baec1" name="a775403b95e4a279d38c627174d2baec1"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> const &amp;) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> &amp;=delete</td></tr>
<tr class="separator:a775403b95e4a279d38c627174d2baec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bcd5b2615a1be03a951353666f9db5"><td class="memItemLeft" align="right" valign="top"><a id="a61bcd5b2615a1be03a951353666f9db5" name="a61bcd5b2615a1be03a951353666f9db5"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> &amp;&amp;) -&gt; <a class="el" href="classteddy_1_1diagram__manager.html">diagram_manager</a> &amp;=default</td></tr>
<tr class="separator:a61bcd5b2615a1be03a951353666f9db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a6e5142fac56713fea1a5f9a1cb3d9235"><td class="memItemLeft" align="right" valign="top"><a id="a6e5142fac56713fea1a5f9a1cb3d9235" name="a6e5142fac56713fea1a5f9a1cb3d9235"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_t</b> = typename <a class="el" href="classteddy_1_1diagram.html">diagram</a>&lt; Data, Degree &gt;::node_t</td></tr>
<tr class="separator:a6e5142fac56713fea1a5f9a1cb3d9235"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3601b1dfda1d0bae23f6d17478c98afb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#a3601b1dfda1d0bae23f6d17478c98afb">diagram_manager</a> (std::size_t varCount, std::size_t nodePoolSize, std::size_t overflowNodePoolSize, std::vector&lt; index_t &gt; order)</td></tr>
<tr class="memdesc:a3601b1dfda1d0bae23f6d17478c98afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes diagram manager.  <a href="classteddy_1_1diagram__manager.html#a3601b1dfda1d0bae23f6d17478c98afb">More...</a><br /></td></tr>
<tr class="separator:a3601b1dfda1d0bae23f6d17478c98afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad285b75b3a4ab8a27d06cd3924493c08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classteddy_1_1diagram__manager.html#ad285b75b3a4ab8a27d06cd3924493c08">diagram_manager</a> (std::size_t varCount, std::size_t nodePoolSize, std::size_t overflowNodePoolSize, <a class="el" href="structteddy_1_1domains_1_1mixed.html">domains::mixed</a> ds, std::vector&lt; index_t &gt; order)</td></tr>
<tr class="memdesc:ad285b75b3a4ab8a27d06cd3924493c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes diagram manager.  <a href="classteddy_1_1diagram__manager.html#ad285b75b3a4ab8a27d06cd3924493c08">More...</a><br /></td></tr>
<tr class="separator:ad285b75b3a4ab8a27d06cd3924493c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab98034c8b05644fa852e15b2d08b18fb"><td class="memItemLeft" align="right" valign="top"><a id="ab98034c8b05644fa852e15b2d08b18fb" name="ab98034c8b05644fa852e15b2d08b18fb"></a>
<a class="el" href="classteddy_1_1node__manager.html">node_manager</a>&lt; Data, Degree, Domain &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes_</b></td></tr>
<tr class="separator:ab98034c8b05644fa852e15b2d08b18fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Data, degree Degree, domain Domain&gt;<br />
class teddy::diagram_manager&lt; Data, Degree, Domain &gt;</div><p >Base class for all diagram managers that generically implements all of the algorithms. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3601b1dfda1d0bae23f6d17478c98afb" name="a3601b1dfda1d0bae23f6d17478c98afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3601b1dfda1d0bae23f6d17478c98afb">&#9670;&nbsp;</a></span>diagram_manager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; <br />
requires (<a class="el" href="structteddy_1_1domains_1_1is__fixed.html">domains::is_fixed</a>&lt;Domain&gt;()())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::diagram_manager </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>varCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nodePoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>overflowNodePoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; index_t &gt;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes diagram manager. </p>
<p >This overload is for managers that have fixed domains (known at copile time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varCount</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">nodePoolSize</td><td>Number of nodes that is pre-allocated. </td></tr>
    <tr><td class="paramname">overflowNodePoolSize</td><td>Size of the additional node pools. </td></tr>
    <tr><td class="paramname">order</td><td>Order of variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad285b75b3a4ab8a27d06cd3924493c08" name="ad285b75b3a4ab8a27d06cd3924493c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad285b75b3a4ab8a27d06cd3924493c08">&#9670;&nbsp;</a></span>diagram_manager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; <br />
requires (domains::is_mixed&lt;Domain&gt;()())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::diagram_manager </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>varCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nodePoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>overflowNodePoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteddy_1_1domains_1_1mixed.html">domains::mixed</a>&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; index_t &gt;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes diagram manager. </p>
<p >This overload is for managers that have mixed domains specified by the <code>ds</code> paramter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varCount</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">nodePoolSize</td><td>Number of nodes that is pre-allocated. </td></tr>
    <tr><td class="paramname">overflowNodePoolSize</td><td>Size of the additional node pools. </td></tr>
    <tr><td class="paramname">ds</td><td>Domains of varibales. </td></tr>
    <tr><td class="paramname">order</td><td>Order of variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e5541e448620e4e39eb9f0314a5276d" name="a8e5541e448620e4e39eb9f0314a5276d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5541e448620e4e39eb9f0314a5276d">&#9670;&nbsp;</a></span>constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::constant </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram representing constant function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value of the constant function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing constant function. </dd></dl>

</div>
</div>
<a id="a53b279ab997be99c116f6a38d20200e9" name="a53b279ab997be99c116f6a38d20200e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b279ab997be99c116f6a38d20200e9">&#9670;&nbsp;</a></span>variable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variable </td>
          <td>(</td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram representing function of single variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram of a function of single variable. </dd></dl>

</div>
</div>
<a id="a4505f796689fd32385ddae310e8d9843" name="a4505f796689fd32385ddae310e8d9843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4505f796689fd32385ddae310e8d9843">&#9670;&nbsp;</a></span>variable_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
<div class="memtemplate">
template&lt;class Foo &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variable_not </td>
          <td>(</td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; second_t&lt;Foo, <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates BDD representing function of complemented variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram of a function of single variable. </dd></dl>

</div>
</div>
<a id="accd754f605dfcab429b6f1d857076219" name="accd754f605dfcab429b6f1d857076219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd754f605dfcab429b6f1d857076219">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram representing function of single variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram of a function of single variable. </dd></dl>

</div>
</div>
<a id="a1f9f8421cd7f33c11f6487e81683c7a1" name="a1f9f8421cd7f33c11f6487e81683c7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9f8421cd7f33c11f6487e81683c7a1">&#9670;&nbsp;</a></span>variables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;std::convertible_to&lt; index_t &gt; T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variables </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td> -&gt; std::vector&lt;<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates vector of diagrams representing functions of single variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>integral type convertible to unsgined int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>initializer list of indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of diagrams. </dd></dl>

</div>
</div>
<a id="a80f56f39c209510b6602ab6863e30899" name="a80f56f39c209510b6602ab6863e30899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f56f39c209510b6602ab6863e30899">&#9670;&nbsp;</a></span>variables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variables </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::vector&lt;<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates vector of diagrams representing functions of single variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>iterator type for the input range. </td></tr>
    <tr><td class="paramname">S</td><td>sentinel type for <code>I</code> . (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element of range of indices represented by integral type convertible to unsgined int. </td></tr>
    <tr><td class="paramname">last</td><td>sentinel for <code>first</code> (end iterator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of diagrams. </dd></dl>

</div>
</div>
<a id="ae647e6868fb5c739e5646635d5523562" name="ae647e6868fb5c739e5646635d5523562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae647e6868fb5c739e5646635d5523562">&#9670;&nbsp;</a></span>variables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::variables </td>
          <td>(</td>
          <td class="paramtype">Is const &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td> -&gt; std::vector&lt;<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates vector of diagrams representing functions of single variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Is</td><td>range of indices represented by integral type convertible to unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>range of Ts (e.g. std::vector&lt;unsigned int&gt;). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of diagrams. </dd></dl>

</div>
</div>
<a id="a926f78f0cea41fd1d3b0ab71d3ff732c" name="a926f78f0cea41fd1d3b0ab71d3ff732c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926f78f0cea41fd1d3b0ab71d3ff732c">&#9670;&nbsp;</a></span>from_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::from_vector </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram from a truth vector of a function. </p>
<p >Example for the function f(x) = max(x0, x1, x2): </p><div class="fragment"><div class="line"><span class="comment">// Truth table:</span></div>
<div class="line">+----+----+----+----+---+----+-----+----+---+</div>
<div class="line">| x1 | x2 | x3 | f  | _ | x1 |  x2 | x3 | f |</div>
<div class="line">+----+----+----+----+---+----+-----+----+---+</div>
<div class="line">| 0  | 0  | 0  | 0  |   | 1  |  0  | 0  | 1 |</div>
<div class="line">| 0  | 0  | 1  | 1  |   | 1  |  0  | 1  | 1 |</div>
<div class="line">| 0  | 0  | 2  | 2  |   | 1  |  0  | 2  | 2 |</div>
<div class="line">| 0  | 1  | 0  | 1  |   | 1  |  1  | 0  | 1 |</div>
<div class="line">| 0  | 1  | 1  | 1  |   | 1  |  1  | 1  | 1 |</div>
<div class="line">| 0  | 1  | 2  | 2  |   | 1  |  1  | 2  | 2 |</div>
<div class="line">+----+----+----+----+---+----+-----+----+---+</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Truth vector:</span></div>
<div class="line">[0 1 2 1 1 2 1 1 2 1 1 2]</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Teddy code:</span></div>
<div class="line"><a class="code hl_class" href="structteddy_1_1ifmdd__manager.html">teddy::ifmdd_manager&lt;3&gt;</a> manager(3, 100, {2, 2, 3});</div>
<div class="line">std::vector&lt;unsigned int&gt; vec {0, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2};</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> f = manager.from_vector(vec);</div>
<div class="ttc" id="aclassteddy_1_1diagram__manager_html_afd258af2e42689cd3887b7c7acd7c64a"><div class="ttname"><a href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">teddy::diagram_manager::diagram_t</a></div><div class="ttdeci">diagram&lt; Data, Degree &gt; diagram_t</div><div class="ttdoc">Alias for the diagram type used in the functions of this manager.</div><div class="ttdef"><b>Definition:</b> diagram_manager.hpp:56</div></div>
<div class="ttc" id="astructteddy_1_1ifmdd__manager_html"><div class="ttname"><a href="structteddy_1_1ifmdd__manager.html">teddy::ifmdd_manager</a></div><div class="ttdoc">Diagram manager for creation and manipulation of (integer) Multi-valued Decision Diagrams (iMDDs).</div><div class="ttdef"><b>Definition:</b> teddy.hpp:150</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>Iterator type for the input range. </td></tr>
    <tr><td class="paramname">S</td><td>Sentinel type for <code>I</code> . (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element of the truth vector. </td></tr>
    <tr><td class="paramname">last</td><td>sentinel for <code>first</code> . (end iterator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing function given by the truth vector. </dd></dl>

</div>
</div>
<a id="a9669d1358d90dc81f5b7205589fd89bd" name="a9669d1358d90dc81f5b7205589fd89bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9669d1358d90dc81f5b7205589fd89bd">&#9670;&nbsp;</a></span>from_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::from_vector </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates diagram from a truth vector of a function. </p>
<p >See the other overload for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Type of the range that contains the truth vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Range representing the truth vector. Elements of the range must be convertible to unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing function given by the truth vector. </dd></dl>

</div>
</div>
<a id="a6eebd0c962003f434168e5ef3a3fc621" name="a6eebd0c962003f434168e5ef3a3fc621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eebd0c962003f434168e5ef3a3fc621">&#9670;&nbsp;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const -&gt; std::vector&lt;uint_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates truth vector from the diagram. </p>
<p >Significance of variables is the same as in the <code>from_vector</code> function i.e. variable on the last level of the diagram is least significant. The following assertion holds: </p><div class="fragment"><div class="line">assert(manager.from_vector(manager.to_vector(d)))</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of ints representing truth vector. </dd></dl>

</div>
</div>
<a id="a1c97c0ed2c5560d5b568b5b02d95055a" name="a1c97c0ed2c5560d5b568b5b02d95055a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c97c0ed2c5560d5b568b5b02d95055a">&#9670;&nbsp;</a></span>to_vector_g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;std::output_iterator&lt; teddy::uint_t &gt; O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::to_vector_g </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates truth vector from the diagram. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">O</td><td>Output iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram. </td></tr>
    <tr><td class="paramname">out</td><td>Output iterator that is used to output the truth vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1553a94121ed1941075723197cc3cde" name="aa1553a94121ed1941075723197cc3cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1553a94121ed1941075723197cc3cde">&#9670;&nbsp;</a></span>from_pla()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
<div class="memtemplate">
template&lt;class Foo &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::from_pla </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1pla__file.html">pla_file</a> const &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fold_type&#160;</td>
          <td class="paramname"><em>foldType</em> = <code>fold_type::Tree</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; second_t&lt;Foo, std::vector&lt;<a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates BDDs defined by PLA file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Foo</td><td>Dummy template to enable SFINE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>PLA file loaded in the instance of <code><a class="el" href="classteddy_1_1pla__file.html" title="Representation of a PLA file.">pla_file</a></code> class. </td></tr>
    <tr><td class="paramname">foldType</td><td>fold type used in diagram creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of diagrams. </dd></dl>

</div>
</div>
<a id="a7372fbb53300004d2649862174fca1ab" name="a7372fbb53300004d2649862174fca1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7372fbb53300004d2649862174fca1ab">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;bin_op Op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two diagrams using given binary operation. </p>
<p >Binary operations are defined in the namespace <code>teddy::ops</code> . All availabe operations are listed in the following table: </p><div class="fragment"><div class="line">+-------------------+---------------------------------------+</div>
<div class="line">| Binary operation  |           Description                 |</div>
<div class="line">+-------------------+---------------------------------------+</div>
<div class="line">| AND               | Logical and. ^                        |</div>
<div class="line">| OR                | Logical or. ^                         |</div>
<div class="line">| XOR               | Logical xor. ^                        |</div>
<div class="line">| NAND              | Logical nand. ^                       |</div>
<div class="line">| NOR               | Logical nor. ^                        |</div>
<div class="line">| EQUAL_TO          | Equal to relation. ^                  |</div>
<div class="line">| NOT_EQUAL_TO      | Not equal to relation. ^              |</div>
<div class="line">| LESS              | Less than relation. ^                 |</div>
<div class="line">| LESS_EQUAL        | Less than or equal relation. ^        |</div>
<div class="line">| GREATER           | Greater than relation. ^              |</div>
<div class="line">| GREATER_EQUAL     | Greater than or equal relation. ^     |</div>
<div class="line">| MIN               | Minimum of two values.                |</div>
<div class="line">| MAX               | Maximum of two values.                |</div>
<div class="line">| PLUS              | Modular addition: (a + b) mod P.      |</div>
<div class="line">| MULTIPLIES        | Modular multiplication: (a * b) mod P |</div>
<div class="line">+-------------------+---------------------------------------+</div>
<div class="line">^ 0 is <span class="keyword">false</span> and 1 is <span class="keyword">true</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Examples:</span></div>
<div class="line">manager.apply&lt;<a class="code hl_struct" href="structteddy_1_1ops_1_1AND.html">teddy::ops::AND</a>&gt;(bdd1, bdd2);</div>
<div class="line">manager.apply&lt;<a class="code hl_struct" href="structteddy_1_1ops_1_1PLUS.html">teddy::ops::PLUS&lt;4&gt;</a>&gt;(mdd1, mdd2);</div>
<div class="ttc" id="astructteddy_1_1ops_1_1AND_html"><div class="ttname"><a href="structteddy_1_1ops_1_1AND.html">teddy::ops::AND</a></div><div class="ttdef"><b>Definition:</b> operators.hpp:187</div></div>
<div class="ttc" id="astructteddy_1_1ops_1_1PLUS_html"><div class="ttname"><a href="structteddy_1_1ops_1_1PLUS.html">teddy::ops::PLUS</a></div><div class="ttdef"><b>Definition:</b> operators.hpp:216</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>first diagram. </td></tr>
    <tr><td class="paramname">r</td><td>second diagram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of <code>l</code> and <code>r</code> . </dd></dl>

</div>
</div>
<a id="a97fe617cf5cc1872e36fd0dca87a7e85" name="a97fe617cf5cc1872e36fd0dca87a7e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fe617cf5cc1872e36fd0dca87a7e85">&#9670;&nbsp;</a></span>left_fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;bin_op Op, std::ranges::input_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::left_fold </td>
          <td>(</td>
          <td class="paramtype">R const &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges diagams in the range using the <code>apply</code> function and binary operation. </p>
<p >Uses left fold order of evaluation (sequentially from the left).</p>
<div class="fragment"><div class="line"><span class="comment">// Example:</span></div>
<div class="line">std::vector&lt;diagram_t&gt; vs = manager.variables({0, 1, 2});</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> product = manager.left_fold&lt;teddy::ops&gt;(vs);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation. </td></tr>
    <tr><td class="paramname">R</td><td>Range containing diagrams (e.g. std::vector&lt;diagram_t&gt;). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Input range of diagrams to be merged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of all diagrams from the range. </dd></dl>

</div>
</div>
<a id="a9954a79a74936ba6494ec15c1cc517e3" name="a9954a79a74936ba6494ec15c1cc517e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9954a79a74936ba6494ec15c1cc517e3">&#9670;&nbsp;</a></span>left_fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;bin_op Op, std::input_iterator I, std::sentinel_for&lt; I &gt; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::left_fold </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges diagams in the range using the <code>apply</code> function and binary operation. </p>
<p >Uses left fold order of evaluation (sequentially from the left).</p>
<div class="fragment"><div class="line"><span class="comment">// Example:</span></div>
<div class="line">std::vector&lt;diagram_t&gt; vs = manager.variables({0, 1, 2});</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> product = manager.left_fold&lt;teddy::ops&gt;(</div>
<div class="line">    vs.begin(), vs.end());</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation. </td></tr>
    <tr><td class="paramname">I</td><td>Range iterator type. </td></tr>
    <tr><td class="paramname">S</td><td>Sentinel type for <code>I</code> (end iterator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Input iterator to the first diagram. </td></tr>
    <tr><td class="paramname">last</td><td>Sentinel for <code>first</code> (end iterator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of all diagrams from the range. </dd></dl>

</div>
</div>
<a id="a366cfc607825c26e5bacc8eba2a3eebe" name="a366cfc607825c26e5bacc8eba2a3eebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366cfc607825c26e5bacc8eba2a3eebe">&#9670;&nbsp;</a></span>tree_fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;bin_op Op, std::ranges::random_access_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::tree_fold </td>
          <td>(</td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges diagams in the range using the <code>apply</code> function and binary operation. </p>
<p >Uses tree fold order of evaluation ((d1 op d2) op (d3 op d4) ...) . Tree fold uses the input range <code>range</code> to store some intermediate results. <code>range</code> is left in valid but unspecified state.</p>
<div class="fragment"><div class="line"><span class="comment">// Example:</span></div>
<div class="line">std::vector&lt;diagram_t&gt; vs = manager.variables({0, 1, 2});</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> product = manager.tree_fold&lt;teddy::ops&gt;(vs);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation. </td></tr>
    <tr><td class="paramname">R</td><td>Range containing diagrams (e.g. std::vector&lt;diagram_t&gt;). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Random access range of diagrams to be merged. (e.g. std::vector) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of all diagrams from the range. </dd></dl>

</div>
</div>
<a id="af84d0aa56905007fa98c48cd2b9f9ae0" name="af84d0aa56905007fa98c48cd2b9f9ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84d0aa56905007fa98c48cd2b9f9ae0">&#9670;&nbsp;</a></span>tree_fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;bin_op Op, std::random_access_iterator I, std::sentinel_for&lt; I &gt; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::tree_fold </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges diagams in the range using the <code>apply</code> function and binary operation. </p>
<p >Uses tree fold order of evaluation ((d1 op d2) op (d3 op d4) ...) . Tree fold uses the input range <code>range</code> to store some intermediate results. <code>range</code> is left in valid but unspecified state.</p>
<div class="fragment"><div class="line"><span class="comment">// Example:</span></div>
<div class="line">std::vector&lt;diagram_t&gt; vs = manager.variables({0, 1, 2});</div>
<div class="line"><a class="code hl_typedef" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> product = manager.tree_fold&lt;teddy::ops&gt;(</div>
<div class="line">    vs.begin(), vs.end());</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Binary operation. </td></tr>
    <tr><td class="paramname">I</td><td>Range iterator type. </td></tr>
    <tr><td class="paramname">S</td><td>Sentinel type for <code>I</code> (end iterator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Random access iterator to the first diagram. </td></tr>
    <tr><td class="paramname">last</td><td>Sentinel for <code>first</code> (end iterator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing merger of all diagrams from the range. </dd></dl>

</div>
</div>
<a id="ade7afec0efb73cfc5f04fd8b936944e2" name="ade7afec0efb73cfc5f04fd8b936944e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7afec0efb73cfc5f04fd8b936944e2">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;in_var_values Vars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vars const &amp;&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; uint_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates value of the function represented by the diagram. </p>
<p >Complexity is <code>O(n)</code> where <code>n</code> is the number of variables.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vars</td><td>Container type that defines operator[] and returns value convertible to unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram. </td></tr>
    <tr><td class="paramname">vs</td><td>Container holding values of variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the function represented by <code>d</code> for variable values given in <code>vs</code> . </dd></dl>

</div>
</div>
<a id="a3666b0ee69571cb6e25f1600ba157824" name="a3666b0ee69571cb6e25f1600ba157824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3666b0ee69571cb6e25f1600ba157824">&#9670;&nbsp;</a></span>satisfy_count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
<div class="memtemplate">
template&lt;class Foo &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> -&gt; second_t&lt;Foo, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of variable assignments for which the functions evaluates to 1. </p>
<p >Complexity is <code>O</code>(|d|) where <code>|d|</code> is the number of nodes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Foo</td><td>Dummy parameter to enable SFINE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of different variable assignments for which the the function represented by <code>d</code> evaluates to 1. </dd></dl>

</div>
</div>
<a id="a6aa0e1f258555c41e9de4462b55f20be" name="a6aa0e1f258555c41e9de4462b55f20be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa0e1f258555c41e9de4462b55f20be">&#9670;&nbsp;</a></span>satisfy_count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_count </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of variable assignments for which the functions evaluates to certain value. </p>
<p >Complexity is <code>O</code>(|d|) where <code>|d|</code> is the number of nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value of the function. </td></tr>
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of different variable assignments for which the the function represented by <code>d</code> evaluates to <code>val</code> . </dd></dl>

</div>
</div>
<a id="a6a2a625d7e1dd9c993c80f7726158d78" name="a6a2a625d7e1dd9c993c80f7726158d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2a625d7e1dd9c993c80f7726158d78">&#9670;&nbsp;</a></span>satisfy_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
<div class="memtemplate">
template&lt;out_var_values Vars, class Foo &gt; <br />
requires (is_bdd&lt;Degree&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const -&gt; second_t&lt;Foo, std::vector&lt;Vars&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all elements of the satisfying set. </p>
<p >Enumerates all elements of the satisfying set of the function i.e. variable assignments for which the Boolean function evaluates to 1.</p>
<p >Complexity is <code>O</code>(n*|Sf|) where <code>|Sf|</code> is the size of the satisfying set and <code>n</code> is the number of variables. Please note that this is quite high for bigger functions and the computation will probably not finish in reasonable time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vars</td><td>Container type that defines <code>operator</code>[] and allows assigning unsigned integers. </td></tr>
    <tr><td class="paramname">Foo</td><td>Dummy parameter to enable SFINE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of <code>Vars</code> . </dd></dl>

</div>
</div>
<a id="a22c60c0ef84d8eddb56b43e209ce10b9" name="a22c60c0ef84d8eddb56b43e209ce10b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c60c0ef84d8eddb56b43e209ce10b9">&#9670;&nbsp;</a></span>satisfy_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;out_var_values Vars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_all </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; std::vector&lt;Vars&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all elements of the satisfying set. </p>
<p >Enumerates all elements of the satisfying set of the function i.e. variable assignments for which the function evaluates to certain value.</p>
<p >Complexity is <code>O</code>(n*|Sf|) where <code>|Sf|</code> is the size of the satisfying set and <code>n</code> is the number of variables. Please note that this is quite high for bigger functions and the computation will probably not finish in reasonable time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vars</td><td>Container type that defines <code>operator</code>[] and allows assigning unsigned integers. std::vector is also allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value of the function. </td></tr>
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of <code>Vars</code> . </dd></dl>

</div>
</div>
<a id="a9dafd546c07f0c5821370788c7c5f09e" name="a9dafd546c07f0c5821370788c7c5f09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dafd546c07f0c5821370788c7c5f09e">&#9670;&nbsp;</a></span>satisfy_all_g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;out_var_values Vars, std::output_iterator&lt; Vars &gt; O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::satisfy_all_g </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all elements of the satisfying set. </p>
<p >Enumerates all elements of the satisfying set of the function i.e. variable assignments for which the function evaluates to certain value.</p>
<p >Complexity is <code>O</code>(n*|Sf|) where <code>|Sf|</code> is the size of the satisfying set and <code>n</code> is the number of variables. Please note that this is quite high for bigger functions and the computation will probably not finish in reasonable time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vars</td><td>Container type that defines <code>operator</code>[] and allows assigning unsigned integers. std::vector is also allowed. </td></tr>
    <tr><td class="paramname">O</td><td>Output iterator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value of the function. </td></tr>
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
    <tr><td class="paramname">out</td><td>Output iterator that is used to output instances of <code>Vars</code> . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac94a0de0c119b2fa40256dd24505f64a" name="ac94a0de0c119b2fa40256dd24505f64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94a0de0c119b2fa40256dd24505f64a">&#9670;&nbsp;</a></span>cofactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::cofactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates cofactor of the functions. </p>
<p >Calculates cofactor of the function i.e. fixes value of the <code>i</code> th variable to the value <code>val</code> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
    <tr><td class="paramname">i</td><td>Index of the variable to be fixed. </td></tr>
    <tr><td class="paramname">val</td><td>Value to which the <code>i</code> th varibale should be fixed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing cofactor of the function. </dd></dl>

</div>
</div>
<a id="a759640699bb5baad483f4cb0bd595e39" name="a759640699bb5baad483f4cb0bd595e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759640699bb5baad483f4cb0bd595e39">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;uint_to_bool F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em> = <code>utils::not_zero</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms values of the function. </p>
<div class="fragment"><div class="line"><span class="comment">// Example of the call with 4-valued MDD.</span></div>
<div class="line">manager.transform(diagram, [](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> 3 - v;</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of the transformation function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
    <tr><td class="paramname">f</td><td>Transformation function that is applied to values of the function. Default value keeps 0 and transform everything else to 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram representing transformed function. </dd></dl>

</div>
</div>
<a id="aece176e6e8455a888e45aee9ccdadde3" name="aece176e6e8455a888e45aee9ccdadde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece176e6e8455a888e45aee9ccdadde3">&#9670;&nbsp;</a></span>dependency_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::dependency_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const -&gt; std::vector&lt;index_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates indices of variables that the function depends on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of indices. </dd></dl>

</div>
</div>
<a id="a2fe950a01ddd987306e62ab994514987" name="a2fe950a01ddd987306e62ab994514987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe950a01ddd987306e62ab994514987">&#9670;&nbsp;</a></span>dependency_set_g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
<div class="memtemplate">
template&lt;std::output_iterator&lt; index_t &gt; O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::dependency_set_g </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates indices of variables that the function depends on. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">O</td><td>Output iterator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram representing the function. </td></tr>
    <tr><td class="paramname">out</td><td>Output iterator that is used to output indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5a3909fd675c908faa256db43d8049c" name="aa5a3909fd675c908faa256db43d8049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a3909fd675c908faa256db43d8049c">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces diagrams to its canonical form. </p>
<p >You probably won't need to call this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagram in a reduced canonical form. </dd></dl>

</div>
</div>
<a id="a0df9c68f93bd16f27f48503a8c2f2652" name="a0df9c68f93bd16f27f48503a8c2f2652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df9c68f93bd16f27f48503a8c2f2652">&#9670;&nbsp;</a></span>node_count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::node_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of nodes that are currently used by the manager. </p>
<p >This function returns number of nodes that are currently stored in the unique tables. Total number of allocated nodes might and probably will be higher. See implementation details on github for details.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of nodes. </dd></dl>

</div>
</div>
<a id="a65d0b80624848f04953e24fc2b39c34d" name="a65d0b80624848f04953e24fc2b39c34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d0b80624848f04953e24fc2b39c34d">&#9670;&nbsp;</a></span>node_count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::node_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const -&gt; std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of nodes in the diagram including terminal nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Diagram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of node. </dd></dl>

</div>
</div>
<a id="a9a02749d3a2902adb581b7b064a78064" name="a9a02749d3a2902adb581b7b064a78064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a02749d3a2902adb581b7b064a78064">&#9670;&nbsp;</a></span>to_dot_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::to_dot_graph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints dot representation of the graph. </p>
<p >Prints dot representation of the entire multi rooted graph to the output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output stream (e.g. <code>std::cout</code> or <code>std::ofstream</code> ) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b8ddc5bdd085e17a7fd7bb1cc9e7f4f" name="a8b8ddc5bdd085e17a7fd7bb1cc9e7f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8ddc5bdd085e17a7fd7bb1cc9e7f4f">&#9670;&nbsp;</a></span>to_dot_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::to_dot_graph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classteddy_1_1diagram__manager.html#afd258af2e42689cd3887b7c7acd7c64a">diagram_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints dot representation of the diagram. </p>
<p >Prints dot representation of the diagram to the output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output stream (e.g. <code>std::cout</code> or <code>std::ofstream</code> ) </td></tr>
    <tr><td class="paramname">d</td><td>Diagram. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cf99b292c8f0e9a77e3c9559aac81e1" name="a7cf99b292c8f0e9a77e3c9559aac81e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf99b292c8f0e9a77e3c9559aac81e1">&#9670;&nbsp;</a></span>gc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::gc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs garbage collection. </p>
<p >Forces the garbage collection to run which removes nodes that are not referenced from the unique tables. These nodes, however, are not deallocated. See implementation details on github for details. GC is run automatically so you probably won't need to run this function yourself. </p>

</div>
</div>
<a id="a384f1b204158d92c60fc90cc91bc3084" name="a384f1b204158d92c60fc90cc91bc3084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384f1b204158d92c60fc90cc91bc3084">&#9670;&nbsp;</a></span>get_var_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_var_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of variables for this manager set in the constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of variables. </dd></dl>

</div>
</div>
<a id="a961fea54d7c7ccefb2dee2bb6e0d155f" name="a961fea54d7c7ccefb2dee2bb6e0d155f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961fea54d7c7ccefb2dee2bb6e0d155f">&#9670;&nbsp;</a></span>get_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_order</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current order of variables. </p>
<p >If no sifting was performed in between call to the constructor and call to this function then the order is the same as specified in the constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of indices. Index at l-th position is the index of variable at l-th level of the diagram. </dd></dl>

</div>
</div>
<a id="a046100716dc71e5d9f2fb08b66c6101b" name="a046100716dc71e5d9f2fb08b66c6101b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046100716dc71e5d9f2fb08b66c6101b">&#9670;&nbsp;</a></span>get_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::get_domains</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return domains of variables. </p>
<p >In case of <code><a class="el" href="structteddy_1_1bdd__manager.html" title="Diagram manager for creation and manipulation of Binary Decision Diagrams.">bdd_manager</a></code> and <code><a class="el" href="structteddy_1_1mdd__manager.html" title="Diagram manager for creation and manipulation of Multi-valued Decision Diagrams.">mdd_manager</a></code> domains of each variable is the same i.e. 2 or P. In case of <code><a class="el" href="structteddy_1_1imdd__manager.html" title="Diagram manager for creation and manipulation of (integer) Multi-valued Decision Diagrams (iMDDs).">imdd_manager</a></code> and <code><a class="el" href="structteddy_1_1ifmdd__manager.html" title="Diagram manager for creation and manipulation of (integer) Multi-valued Decision Diagrams (iMDDs).">ifmdd_manager</a></code> the domains are the same as set in the constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of domains. </dd></dl>

</div>
</div>
<a id="a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0" name="a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfa6eeab88b4ebb7d3ed1a4f0c9c4c0">&#9670;&nbsp;</a></span>set_cache_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::set_cache_ratio </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the relative cache size w.r.t the number of nodes. </p>
<p >Size of the cache is calculated as: </p><div class="fragment"><div class="line">ratio * uniqueNodeCount</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Number from the interval (0,oo). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a110856ce25c5aa8af6c36ffc3c753c97" name="a110856ce25c5aa8af6c36ffc3c753c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110856ce25c5aa8af6c36ffc3c753c97">&#9670;&nbsp;</a></span>set_gc_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data , degree Degree, domain Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classteddy_1_1diagram__manager.html">teddy::diagram_manager</a>&lt; Data, Degree, Domain &gt;::set_gc_ratio </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets ratio used to determine new node pool allocation. </p>
<p >New pool is allocated if: </p><div class="fragment"><div class="line">garbageCollectedNodes &lt; ratio * initNodeCount</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Number from the interval [0,1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="diagram_8hpp_source.html">diagram.hpp</a></li>
<li><a class="el" href="diagram__manager_8hpp_source.html">diagram_manager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 8 2022 11:01:32 for TeDDy by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
