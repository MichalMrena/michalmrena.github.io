<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ðŸ§¸ TeDDy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">ðŸ§¸ TeDDy </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>TeDDy is a C++ library for the creation and manipulation of decision diagrams. It is being developed at the <a href="https://www.fri.uniza.sk/en/">Faculty of Management Science and Informatics</a>, the <a href="https://www.uniza.sk/index.php/en/">University of Å½ilina</a> at the <a href="https://ki.fri.uniza.sk/">Department of Informatics</a>. <br  />
 This text assumes that the reader is familiar with decision diagrams to some extent. Our library supports <a href="https://en.wikipedia.org/wiki/Binary_decision_diagram">Binary Decision Diagrams</a> (BDDs) and their generalization Multi-Valued Decision Diagrams (MDDs).</p>
<hr  />
 <h1><a class="anchor" id="autotoc_md2"></a>
Contents</h1>
<ul>
<li>How to install</li>
<li>How to use</li>
<li>Publications and citation</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md4"></a>
How to install</h1>
<p>TeDDY is a header-only library. There are two principal ways to use it in your project.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Copy the files</h2>
<p>The simplest way is to download the library (using <code>git clone</code>, <a href="https://github.com/MichalMrena/DecisionDiagrams/releases">one of the releases</a>, or <a href="https://github.com/MichalMrena/DecisionDiagrams/archive/refs/heads/master.zip">download as zip</a>) and place the <a href="./libteddy/">libteddy</a> folder somewhere where your compiler can see it e.g., directly in your project.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Using cmake</h2>
<p>You can install the library using standard procedure. <br  />
 </p><div class="fragment"><div class="line">git clone git@github.com:MichalMrena/DecisionDiagrams.git</div>
<div class="line">cd DecisionDiagrams</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
<div class="line">sudo make install</div>
</div><!-- fragment --><p> This installs library files to the default location which should be visible to your compiler. You can specify a different path by passing the <code>-DCMAKE_INSTALL_PREFIX=&lt;your path&gt;</code> to cmake. Cmake writes paths to all installed files into the <code>install_manifest.txt</code> file. To uninstall the library go to the directory where the <code>install_manifest.txt</code> file is located and run <code>[sudo] xargs rm &lt; install_manifest.txt</code>. <br  />
 Subsequently, you can use the library in the following way: </p><div class="fragment"><div class="line">find_package(</div>
<div class="line">    TeDDy REQUIRED</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">add_executable(</div>
<div class="line">    yourtarget</div>
<div class="line">        main.cpp</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">target_link_libraries(</div>
<div class="line">    yourtarget PRIVATE teddy::teddy</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Compiling</h2>
<p>TeDDy uses features from <code>C++20</code> so you may need to set your compiler to this version of the C++ language by using the <code>-std=c++20</code> flag for <code>clang++</code> and <code>g++</code> and <code>/std:c++20</code> for MSVC. If you are using <code>cmake</code> it should handle this for you. We tested it on Linux with <code>g++ 10.0.0</code>, <code>clang++ (libc++) 13.0.0</code>, <code>clang++ (libstdc++) 11.0.0</code>, and on Windows with <code>MSVC 19.31.31107</code>. <br  />
</p>
<h1><a class="anchor" id="autotoc_md8"></a>
How to use</h1>
<p>TeDDy consists of two modules. The first module <code>teddy-core</code> contains algorithms for general manipulation and the creation of decision diagrams. The second module <code>teddy-reliability</code> contains algorithms aimed at reliability analysis utilizing decision diagrams.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Core</h2>
<p>All library functions are accessible via an instance of a diagram manager. TeDDy offers four diagram managers for different kinds of decision diagrams. <br  />
</p><ol type="1">
<li><code>bdd_manager</code> for Binary Decision Diagrams (BDDs). <br  />
</li>
<li><code>mdd_manager&lt;M&gt;</code> for Multi-valued Decision Diagrams (MDDs) representing Multiple-Valued logic functions. The domain of each variable is <code>{0,1,...,M-1}</code> and the set of values of the function is also <code>{0,1,...,M-1}</code>. <br  />
</li>
<li><code>imdd_manager</code> for (integer) Multi-valued Decision Diagrams (iMDDs) representing integer functions. The domain of each variable can be a different set of the form <code>{0,1,2,...,di-1}</code> where <code>di</code> for each variable is specified in the constructor. The set of values of the function is a set of the form <code>{0,1,2,...}</code>.</li>
<li><code>ifmdd_manager&lt;M&gt;</code> for (integer) Multi-valued Decision Diagrams (iMDDs) representing integer functions. The domain of each variable can be a different set of the form <code>{0,1,2,...,min(di,M-1)}</code> where the <code>M</code> is specified as the template parameter and <code>di</code> for each variable is specified in the constructor. The set of values of the function is a set of the form <code>{0,1,2,...}</code>. <br  />
</li>
</ol>
<p>Managers 1, 2, and 4 use nodes with more compact memory representation since the maximum of the domains is known at compile time. The only difference between 3 and 4 is in this property so if <code>M</code> is known it is better to use the manager 4. <br  />
</p>
<p>Typical usage of the library can be summarized in 3 steps:</p><ol type="1">
<li>Choose one of the four diagram managers.</li>
<li>Create a decision diagram representing desired function(s).</li>
<li>Examine the properties of the function(s). <br  />
</li>
</ol>
<p>The following example shows the above steps for the <code>bdd_manager</code> and Boolean function <code>f(x) = (x0 and x1) or (x2 and x3)</code>:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;libteddy/core.hpp&gt;</div>
<div class="line">#include &lt;cassert&gt;</div>
<div class="line">#include &lt;fstream&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    // 4 variables, 1000 pre-allocated nodes (see memory management)</div>
<div class="line">    teddy::bdd_manager manager(4, 1&#39;000);</div>
<div class="line"> </div>
<div class="line">    // Alias for the type of the diagram, or you can just use auto.</div>
<div class="line">    using diagram_t = teddy::bdd_manager::diagram_t;</div>
<div class="line"> </div>
<div class="line">    // Create diagram for a single variable (indices start at 0).</div>
<div class="line">    diagram_t x0 = manager.variable(0);</div>
<div class="line">    diagram_t x1 = manager.variable(1);</div>
<div class="line"> </div>
<div class="line">    // operator() serves the same purpose as .variable call.</div>
<div class="line">    // It is convenient to create a reference to the manager with name x.</div>
<div class="line">    teddy::bdd_manager&amp; x = manager;</div>
<div class="line">    diagram_t x2 = x(2);</div>
<div class="line"> </div>
<div class="line">    // Diagrams for multiple variables can be created at once.</div>
<div class="line">    std::vector&lt;diagram_t&gt; xs = manager.variables({0, 1, 2, 3});</div>
<div class="line"> </div>
<div class="line">    // diagram_t is cheap handle type, multiple diagrams can point</div>
<div class="line">    // to the same node, to test whether they do use .equals.</div>
<div class="line">    assert(x1.equals(xs[1]));</div>
<div class="line"> </div>
<div class="line">    // (to simplify operator names)</div>
<div class="line">    using namespace teddy::ops;</div>
<div class="line">    // Finally, to create a diagram for the function:</div>
<div class="line">    // f(x) = (x0 and x1) or (x2 and x3)</div>
<div class="line">    // we use the apply function.</div>
<div class="line">    diagram_t f1 = manager.apply&lt;AND&gt;(xs[0], xs[1]);</div>
<div class="line">    diagram_t f2 = manager.apply&lt;AND&gt;(xs[2], xs[3]);</div>
<div class="line">    diagram_t f  = manager.apply&lt;OR&gt;(f1, f2);</div>
<div class="line"> </div>
<div class="line">    // Now that we have diagram for the funtion f, we can test its properties</div>
<div class="line">    // e.g., evaluate it for give variable assignment.</div>
<div class="line">    const int val = manager.evaluate(f, std::array {1, 1, 0, 1});</div>
<div class="line">    assert(val == 1);</div>
<div class="line"> </div>
<div class="line">    // We can see how the diagram looks like by printing its dot representation</div>
<div class="line">    // into a file or console and visualizing it using e.g. graphviz.</div>
<div class="line">    manager.to_dot_graph(std::cout, f);</div>
<div class="line">    std::ofstream ofst(&quot;f.dot&quot;);</div>
<div class="line">    manager.to_dot_graph(ofst, f);</div>
<div class="line"> </div>
<div class="line">    // To calculate number of different variable assignments for which the</div>
<div class="line">    // function evaluates to 1 we can use .satisfy_count.</div>
<div class="line">    long long sc = manager.satisfy_count(1, f);</div>
<div class="line"> </div>
<div class="line">    // We can also enumerate all variable assignments for which the</div>
<div class="line">    // the function evaluates to 1.</div>
<div class="line">    std::vector&lt;std::array&lt;int, 4&gt;&gt; sa</div>
<div class="line">        = manager.satisfy_all&lt;std::array&lt;int, 4&gt;&gt;(1, f);</div>
<div class="line">}</div>
</div><!-- fragment --><p> All diagram managers have the same API. <b>Full documentation</b> is available <a href="https://michalmrena.github.io/teddy.html">here</a>. For more examples see the <a href="./examples/">examples</a> folder.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Reliability</h2>
<p>As with diagram manipulation, the reliability analysis functions are accessible via an instance of a reliability manager. There are four reliability managers analogous to diagram managers.</p><ol type="1">
<li><code>bss_manager</code> for Binary-State Systems (BSS). Uses BDDs. <br  />
</li>
<li><code>mss_manager&lt;M&gt;</code> for homogeneous Multi-State Systems (MSS). Domains of variables and sets of values of functions correspond to the number of component/system states. Uses MDDs. <br  />
</li>
<li><code>imss_manager</code> for non-homogeneous Multi-State Systems (MSS). Domains of variables and sets of values of functions correspond to the number of component/system states. Uses iMDDs. <br  />
</li>
<li><code>ifmss_manager&lt;M&gt;</code> for non-homogenous Multi-State Systems (MSS). Domains of variables and sets of values of functions correspond to the number of component/system states. Uses ifMDDs. <br  />
</li>
</ol>
<p>Note that each reliability manager is a child class of the corresponding diagram manager, hence, the advantages and disadvantages of the base managers apply. All reliability managers have the same API. <b>Full documentation</b> is available <a href="https://michalmrena.github.io/teddy.html">here</a>.</p>
<p>The usage of reliability managers is analogous to diagram managers. Many of the reliability functions have a parameter that represents component state probabilities. The parameter does not have a specific type but instead uses a template. The reason is that probabilities can be stored in different combinations of containers such as <code>std::vector</code> or <code>std::array</code>. The type holding the probabilities must satisfy that if <code>ps</code> is the name of the parameter then the expression <code>ps[i][k]</code> returns the probability that the <code>i</code>-th component is in the state <code>k</code>. The following example shows the basic usage of the reliability manager: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;libteddy/reliability.hpp&gt;</div>
<div class="line">#include &lt;array&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &quot;libteddy/details/reliability_manager.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    // First, we need to create a diagram for the structure function.</div>
<div class="line">    // We can use the truth vector of the function.</div>
<div class="line">    std::vector&lt;int&gt; vector(</div>
<div class="line">        {0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,2,2,2,2,2,1,2,2,2,2,2}</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    // The truth vector describes a nonhomogeneous system, so we also need.</div>
<div class="line">    // The number of states of each component.</div>
<div class="line">    std::vector&lt;int&gt; domains({2, 3, 2, 3});</div>
<div class="line"> </div>
<div class="line">    // 4 components, 1000 pre-allocated nodes (see memory management)</div>
<div class="line">    teddy::ifmss_manager&lt;3&gt; manager(4, 1&#39;000, domains);</div>
<div class="line"> </div>
<div class="line">    // Alias for the type of the diagram, or you can just use auto.</div>
<div class="line">    using diagram_t = teddy::ifmss_manager&lt;3&gt;::diagram_t;</div>
<div class="line">    diagram_t sf = manager.from_vector(vector);</div>
<div class="line"> </div>
<div class="line">    // We can use different combinations of std::vector, std::array or similar containers.</div>
<div class="line">    // We chose vector of arrays here to hold component state probabilities.</div>
<div class="line">    std::vector&lt;std::array&lt;double, 3&gt;&gt; ps</div>
<div class="line">    ({</div>
<div class="line">        {0.1, 0.9, 0.0},</div>
<div class="line">        {0.2, 0.6, 0.2},</div>
<div class="line">        {0.3, 0.7, 0.0},</div>
<div class="line">        {0.1, 0.6, 0.3}</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    // To calculate system availability or unavailability for a given.</div>
<div class="line">    // System state (1) is as simple as:</div>
<div class="line">    const double A = manager.calculate_availability(1, ps, sf);</div>
<div class="line">    const double U = manager.calculate_unavailability(1, ps, sf);</div>
<div class="line">    std::cout &lt;&lt; &quot;A = &quot; &lt;&lt; A &lt;&lt; &quot;\n&quot;;</div>
<div class="line">    std::cout &lt;&lt; &quot;U = &quot; &lt;&lt; U &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">    // We can also simply enumerate all Minimal Cut Vectors for a given system</div>
<div class="line">    // state (1). We just need to specify a type that will store the vectors.</div>
<div class="line">    // In this case, we used std::array:</div>
<div class="line">    std::vector&lt;std::array&lt;int, 4&gt;&gt; MCVs = manager.mcvs&lt;std::array&lt;int, 4&gt;&gt;(sf, 1);</div>
<div class="line"> </div>
<div class="line">    // Importance measures are defined in terms of logic derivatives.</div>
<div class="line">    // Since there are different types of derivatives the calculation of</div>
<div class="line">    // the derivatives is separated from the calculation of importance measures.</div>
<div class="line"> </div>
<div class="line">    // To calculate Structural Importance we first need to calculate</div>
<div class="line">    // the derivative.</div>
<div class="line">    diagram_t dpbd = manager.dpld({2, 1, 0}, teddy::dpld::type_3_decrease(1), sf);</div>
<div class="line"> </div>
<div class="line">    // Now, to calculate the Structural Importance of the second component,</div>
<div class="line">    // we use the derivative.</div>
<div class="line">    const double SI_2 = manager.structural_importance(dpbd);</div>
<div class="line">    std::cout &lt;&lt; &quot;SI_2 = &quot; &lt;&lt; SI_2 &lt;&lt; &quot;\n&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><p> For more examples see the <a href="./examples/">examples</a> folder.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Memory management</h2>
<h3><a class="anchor" id="autotoc_md12"></a>
Node pool</h3>
<p>TeDDy uses a pool of pre-allocated nodes. The initial number of allocated nodes (<code>nodePoolSize</code>) is provided by the user in the manager's constructor. It is hard to give general advice on how many nodes you should allocate. On modern hardware, it should not be a problem to allocate a couple of millions of nodes that will occupy roughly tens or hundreds of MiBs of memory depending on the type of manager used. The more nodes you allocate at the beginning, the fewer allocations will be needed during computations resulting in a faster computation. Clearly, for small examples, hundreds or thousands of nodes are just enough. <br  />
</p>
<p>If there are no nodes left in the pool, automatic garbage collection (<code>gc</code>) is performed to recycle unused nodes. Let <code>gcCount</code> be the number of garbage collected nodes (returned to the pool). Then if <code>gcCount &lt; gcThreshold * nodePoolSize</code> an additional node poll of size <code>overflowNodePoolSize</code> is allocated. The default value of the parameter <code>gcThreshold</code> is <code>0.05</code>. The user can adjust the parameter by using <code>set_gc_ratio</code> function. The size of the additional pool <code>overflowNodePoolSize</code> can be set in the manager's constructor alongside the <code>nodePoolSize</code>. The default value is <code>overflowNodePoolSize = nodePoolSize / 2</code>.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Cache</h3>
<p>The library uses a cache to speed up diagram manipulation by avoiding expensive recomputations. The size of the cache depends on the number of currently used nodes. The size is calculated as <code>cacheRatio * uniqueNodeCount</code>, where the <code>uniqueNodeCount</code> is the number of unique nodes currently used by the manager. The default value of <code>cacheRatio</code> is <code>0.5</code>. The user can adjust the ratio by using <code>set_cache_ratio</code> function. The bigger the cache the better the computation speed. However, a bigger ratio means higher memory consumption. It is up to the user to keep the two factors balanced. From the experience even cache ratios <code>1.0</code> of <code>2.0</code> are fine.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Assertions</h2>
<p>By default, the library contains runtime assertions that perform various checks such as bounds checking and similar. In case you want to ignore these assertions e.g. in some performance-demanding use case, you need to put <code>#define NDEBUG</code> before you include the TeDDy header. <br  />
</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Variable ordering</h2>
<p>The user can specify the order of variables in the constructor of the manager. After that, the order stays the same. The user can explicitly invoke the reordering heuristic by using the <code>force_reorder</code> function. The heuristic tries to minimize the number of nodes in all diagrams managed by the manager.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Publications and citation</h1>
<p><em>A paper describing TeDDy itself is in preparation.</em> <br  />
 Also, we have published several papers on decision diagrams and reliability analysis. The following papers had an experimental section where we examined various properties of decision diagrams using TeDDy:</p>
<p>Mrena, M., &amp;#38; Kvassay, M. (2021). <b>Comparison of Left Fold and Tree Fold Strategies in Creation of Binary Decision Diagrams</b>. <em>2021 International Conference on Information and Digital Technologies (IDT)</em>, 341â€“352. <a href="https://doi.org/10.1109/IDT52577.2021.9497593">https://doi.org/10.1109/IDT52577.2021.9497593</a> &#160; <br  />
</p>
<p>Mrena, M., Sedlacek, P., &amp;#38; Kvassay, M. (2021). <b>Linear Fold and Tree Fold in Creation of Binary Decision Diagrams of Standard Benchmarks.</b> <em>2021 11th IEEE International Conference on Intelligent Data Acquisition and Advanced Computing Systems: Technology and Applications (IDAACS)</em>, <em>2</em>, 1120â€“1125. <a href="https://doi.org/10.1109/IDAACS53288.2021.9660940">https://doi.org/10.1109/IDAACS53288.2021.9660940</a> &#160; <br  />
</p>
<p>Mrena, M., Kvassay, M., &amp;#38; Czapp, S. (2022). <b>Single and Series of Multi-valued Decision Diagrams in Representation of Structure Function.</b> <em>Lecture Notes in Networks and Systems</em>, <em>484 LNNS</em>, 176â€“185. <a href="https://doi.org/10.1007/978-3-031-06746-4_17">https://doi.org/10.1007/978-3-031-06746-4_17</a> &#160; <br  />
</p>
<p>Mrena, M., &amp;#38; Kvassay, M. (2022). <b>Comparison of Single MDD and Series of MDDs in the Representation of Structure Function of Series-Parallel MSS.</b> <em>2022 IEEE 16th International Scientific Conference on Informatics (Informatics)</em>, 225â€“230. <a href="https://doi.org/10.1109/INFORMATICS57926.2022.10083458">https://doi.org/10.1109/INFORMATICS57926.2022.10083458</a> &#160; <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
